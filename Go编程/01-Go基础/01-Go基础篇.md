# Go基础篇

## 概念

### go 简介

以c语言为原型，以及借鉴其他语言的一些特性，来简化操作，并在2009年，go语言诞生。

**思想：Less can be more 大道至简，小而蕴真**

### Go的优点

- **性能（机器代码）**：GoLang 是一种编译语言，可以编译为机器代码，编译后的二进制文件可以直接部署到目标机器而无需额外的依赖。性能优于那些解释语言。
- **动态的语言感受**：GoLang 是一种静态语言，但它给开发人员带来了动态语言的感觉。作为静态语言，在进行编译时可以检测到许多隐藏的问题，尤其是语法错误。此外，有许多软件包供开发人员使用，在开发过程中很容易导入它们，这使我们不再担心它的功能，让我们觉得我们正在处理动态语言。
- **并发支持**：它可以充分利用多核功能。GoLang 使用 **goroutine** 来实现并发性，它提供了一个非常优雅的goroutine调度程序系统，可以很容易地生成数百万个goroutine。堆栈使用也可以动态扩展/收缩，这使内存使用更加智能。这与Java线程不同，后者通常只允许创建数千个线程。
- **内置运行时支持GC**：虽然它的GC并不完美，但它可以满足大多数关于垃圾收集的要求。
- **简单易学**：GoLang的作者都有C背景，GoLang有C基因。有25个关键词但具有丰富的表达能力。它可以支持几乎所有在其他语言中看到的功能，如继承，重载，对象等。
- **工具链**：有许多易于使用的内置工具可以帮助开发人员编写可维护和可读的代码。效率大大提高。这些包括**gofmt**，**goimport**等。它们可以使我们的代码看起来标准化，并且可以简化审查工作。
- **本机C支持**：可以在Go程序中嵌入C代码，以便可以使用许多功能强大的C库。

### Go语言的主要特征

1. 自动立即回收。
2. 更丰富的内置类型。
3. 函数多返回值。
4. 错误处理。
5. 匿名函数和闭包。
6. 类型和接口。
7. 并发编程。
8. 反射。
9. 语言交互性。

### Go语言命名

1. Go的函数、变量、常量、自定义类型、包`(package)`的命名方式遵循以下规则：

```
1）首字符可以是任意的Unicode字符或者下划线
2）剩余字符可以是Unicode字符、下划线、数字
3）字符长度不限
```

2. Go只有25个关键字

```
    break        default      func         interface    select
    case         defer        go           map          struct
    chan         else         goto         package      switch
    const        fallthrough  if           range        type
    continue     for          import       return       var
```

3. Go还有37个保留字

```
Constants:    true  false  iota  nil

Types:  int  int8  int16  int32  int64  
        uint  uint8  uint16  uint32  uint64  uintptr
        float32  float64  complex128  complex64
        bool  byte  rune  string  error

Functions:  make  len  cap  new  append  copy  close  delete
            complex  real  imag
            panic  recover
```

4. 可见性

```
1）声明在函数内部，是函数的本地值，类似private
2）声明在函数外部，是对当前包可见(包内所有.go文件都可见)的全局值，类似protect
3）声明在函数外部且首字母大写是所有包可见的全局值,类似public
```

### Go语言声明

有四种主要声明方式：

```
var（声明变量）, const（声明常量）, type（声明类型） ,func（声明函数）。
```

Go的程序是保存在多个.go文件中，文件的第一行就是``package XXX``声明，用来说明该文件属于哪个包(package)，package声明下来就是import声明，再下来是类型，变量，常量，函数的声明。

## 安装

### 下载 go 软件

Go官网下载地址：https://golang.org/dl/

### 配置GOPATH

`GOPATH`是一个环境变量，是`go`项目的存放路径，所有的项目代码都放到`GOPATH`的`src`目录下。

【以windows为例】

- windows下设置环境变量，变量名为【GOPATH】，变量值为【D:\GoProject】。
- 同时在`path`里面添加`go`的安装目录和`GOPATH`目录
- 在`GOPATH`目录下，创建【bin】、【pkg】、【src】三个子文件夹
  - bin：用来存放编译后生成的可执行文件
  - pkg：用来存放编译后生成的归档文件
  - src：用来存放源码文件

![image-20230621222234121](./assets/01-Go基础篇/image-20230621222234121.png)

### go的项目目录

在进行`Go`语言开发的时候，代码总是会保存在`$GOPATH/src`目录下。

在工程经过`go build`、`go install`或`go get`等指令后，会将下载的第三方包源代码文件放在`$GOPATH/src`目录下， 产生的二进制可执行文件放在 `$GOPATH/bin`目录下，生成的中间缓存文件会被保存在 `$GOPATH/pkg` 下。

如果使用版本管理工具（`Version Control System`，`VCS`。常用如`Git`）来管理项目代码时，只需要添加`$GOPATH/src`目录的源代码即可。`bin` 和 `pkg` 目录的内容无需版本控制。

## 第一个 go 程序

```go
package main  // 声明 main 包，表明当前是一个可执行程序

import "fmt"  // 导入内置 fmt 

func main(){  // main函数，是程序执行的入口
    fmt.Println("Hello World!")  // 在终端打印 Hello World!
}
```

- 编译：在当前程序目录下执行：`go build`

`go`编译器会去 `GOPATH`的`src`目录下查找要编译的`hello`项目

编译得到的可执行文件会保存在执行编译命令的当前目录下，如果是`windows`平台会在当前目录下找到`hello.exe`可执行文件。

- 执行：然后在终端直接执行该`hello.exe`文件

```bash
hello.exe
```

- 其他：还可以使用-o参数来指定编译后可执行文件的名字。

```bash
go build -o hello.exe
```

## go 常用命令

在命令行执行go命令查看相关的Go语言命令：

```bash
$ go
Go is a tool for managing Go source code.

Usage:

        go <command> [arguments]

The commands are:

        bug         start a bug report
        build       compile packages and dependencies
        clean       remove object files and cached files
        doc         show documentation for package or symbol
        env         print Go environment information
        fix         update packages to use new APIs
        fmt         gofmt (reformat) package sources
        generate    generate Go files by processing source
        get         add dependencies to current module and install them
        install     compile and install packages and dependencies
        list        list packages or modules
        mod         module maintenance
        work        workspace maintenance
        run         compile and run Go program
        test        test packages
        tool        run specified go tool
        version     print Go version
        vet         report likely mistakes in packages

Use "go help <command>" for more information about a command.

Additional help topics:

        buildconstraint build constraints
        buildmode       build modes
        c               calling between Go and C
        cache           build and test caching
        environment     environment variables
        filetype        file types
        go.mod          the go.mod file
        gopath          GOPATH environment variable
        gopath-get      legacy GOPATH go get
        goproxy         module proxy protocol
        importpath      import path syntax
        modules         modules, module versions, and more
        module-get      module-aware go get
        module-auth     module authentication using go.sum
        packages        package lists and patterns
        private         configuration for downloading non-public code
        testflag        testing flags
        testfunc        testing functions
        vcs             controlling version control with GOVCS

Use "go help <topic>" for more information about that topic.
```

| 命令          | 含义                                                         |
| ------------- | ------------------------------------------------------------ |
| go env        | 用于打印Go语言的环境信息                                     |
| go run        | 可以编译并运行命令源码文件                                   |
| go get        | 可以根据要求和实际情况从互联网上下载或更新指定的代码包及其依赖包，并对它们进行编译和安装 |
| go build      | 用于编译我们指定的源码文件或代码包以及它们的依赖包           |
| go install    | 用于编译并安装指定的代码包及它们的依赖包                     |
| go clean      | 会删除掉执行其它命令时产生的一些文件和目录                   |
| go doc        | 可以打印附于Go语言程序实体上的文档。可以通过把程序实体的标识符作为该命令的参数来达到查看其文档的目的 |
| go test       | 用于对Go语言编写的程序进行测试                               |
| go list       | 列出指定的代码包的信息                                       |
| go fix        | 会把指定代码包的所有Go语言源码文件中的旧版本代码修正为新版本的代码 |
| go vet        | 一个用于检查Go语言源码中静态错误的简单工具                   |
| go tool pprof | 交互式的访问概要文件的内容。                                 |

## Golang 内置类型和函数

### 内置类型

#### 值类型

- bool
- int(32 or 64)， int8， int16， int32， int64
- uint(32 or 64)， uint8(byte)， uint16， uint32， uint64
- float32， float64
- string
- complex64， complex128
- array： 固定长度的数组

#### 引用类型：(指针类型)

- slice：序列数组(最常用)
- map：映射
- chan：管道

### 内置函数

Go 语言拥有一些不需要进行导入操作就可以使用的内置函数。它们有时可以针对不同的类型进行操作，例如：len、cap 和 append，或必须用于系统级的操作，例如：panic。因此，它们需要直接获得编译器的支持。

| 函数名         | 含义                                                         |
| -------------- | ------------------------------------------------------------ |
| append         | 用来追加元素到数组、slice中,返回修改后的数组、slice          |
| close          | 主要用来关闭channel                                          |
| delete         | 从map中删除key对应的value                                    |
| panic          | 停止常规的goroutine  （panic和recover：用来做错误处理）      |
| recover        | 允许程序定义goroutine的panic动作                             |
| real           | 返回complex的实部   （complex、real imag：用于创建和操作复数） |
| imag           | 返回complex的虚部                                            |
| make           | 用来分配内存，返回Type本身(只能应用于slice, map, channel)    |
| new            | 用来分配内存，主要用来分配值类型，比如int、struct。返回指向Type的指针 |
| cap            | 用来分配内存，主要用来分配值类型，比如int、struct。返回指向Type的指针 |
| copy           | 用于复制和连接slice，返回复制的数目                          |
| len            | 来求长度，比如string、array、slice、map、channel ，返回长度  |
| print、println | 底层打印函数，在部署环境中建议使用 fmt 包                    |

### 内置接口error

```go
type error interface { // 只要实现了Error()函数，返回值为String的都实现了err接口

    Error()    String

}
```

## Init 函数和 main 函数

### init 函数

go语言中 `init` 函数用于包`(package)`的初始化，该函数是go语言的一个重要特性。

- init函数是用于程序执行前做包的初始化的函数，比如初始化包里的变量等

- 每个包可以拥有多个init函数
- 包的每个源文件也可以拥有多个init函数
- 同一个包中多个init函数的执行顺序go语言没有明确的定义(说明)

- 不同包的init函数按照包导入的依赖关系决定该初始化函数的执行顺序

- init函数不能被其他函数调用，而是在main函数执行之前，自动被调用

### main 函数

Go语言程序的默认入口函数(主函数)：``func main()``，函数体用``｛｝``一对括号包裹。

```go
func main(){ //函数体
}
```

###  init 函数和 main 函数的异同

- 相同点：两个函数在定义时不能有任何的参数和返回值，且Go程序自动调用。
- 不同点：
  - init可以应用于任意包中，且可以重复定义多个。
  - main函数只能用于main包中，且只能定义一个。

两个函数的执行顺序：

- 对同一个go文件的 `init()` 调用顺序是从上到下的。
- 对同一个package中不同文件是按文件名字符串比较“从小到大”顺序调用各文件中的`init()`函数。
- 对于不同的`package`，如果不相互依赖的话，按照main包中 "先`import`的后调用" 的顺序调用其包中的`init()`，如果`package`存在依赖，则先调用最早被依赖的`package`中的`init()`，最后调用`main`函数。
- 如果`init`函数中使用了`println()`或者`print()`你会发现在执行过程中这两个不会按照你想象中的顺序执行。这两个函数官方只推荐在测试环境中使用，对于正式环境不要使用。

## 下划线

### 含义

`_`是特殊标识符，用来忽略结果。

### 下划线在import中

在Golang里，import的作用是导入其他package。

import 下划线（如：import _ hello/imp）的作用：当导入一个包时，该包下的文件里所有init()函数都会被执行，然而，有些时候我们并不需要把整个包都导入进来，**仅仅是是希望它执行init()函数**而已。这个时候就可以使用 import _ 引用该包。即使用【import _ 包路径】只是引用该包，仅仅是为了调用init()函数，所以无法通过包名来调用包中的其他函数。

示例：

- 代码结构

```
src 
|
+--- main.go            
|
+--- hello
     |
     +--- hello.go
```

- main.go

```go
package main

import _ "./hello"

func main() {
    // hello.Print() 
    //编译报错：./main.go:6:5: undefined: hello
}
```

- hello.go

```go
package hello

import "fmt"

func init() {
    fmt.Println("imp-init() come here.")
}

func Print() {
    fmt.Println("Hello!")
}
```

输出结果：

```
imp-init() come here.
```

### 下划线在代码中

```go
package main

import (
    "os"
)

func main() {
    buf := make([]byte, 1024)
    f, _ := os.Open("./text.txt")
    defer f.Close()
    for {
        n, _ := f.Read(buf)
        if n == 0 {
            break    

        }
        os.Stdout.Write(buf[:n])
    }
}
```

- 解释1：**下划线意思是忽略这个变量**。比如``os.Open``，返回值为``*os.File，error``；普通写法是``f,err := os.Open("xxxxxxx")``。如果此时不需要知道返回的错误值，就可以用``f, _ := os.Open("xxxxxx")``，如此则忽略了error变量。

- 解释2：占位符，意思是那个位置本应赋给某个值，但是咱们不需要这个值。所以就把该值赋给下划线，意思是**丢掉不要**。这样编译器可以更好的优化，任何类型的单个值都可以丢给下划线。这种情况是**占位用的**，方法返回两个结果，而你只想要一个结果。那另一个就用 "_" 占位，而如果用变量的话，不使用，编译器是会报错的。
- 补充：第二个import就是不直接使用 mysql 包，只是执行一下这个包的init函数，把 mysql 的驱动注册到sql包里，然后程序里就可以使用 sql 包来访问 mysql 数据库了。

```go
import "database/sql"
import _ "github.com/go-sql-driver/mysql"
```

## 变量和常量

### 变量

#### 什么是变量

变量是对计算机内存中数据的一个引用或一个符号表,用于方便地在代码中对数据进行操作。

#### 变量类型

- 基本类型：bool、string、int、complex、byte等。
- 聚合类型：数组和切片、结构体、Map。
- 引用类型：指针、接口、函数类型和channel。

Go作为一门静态语言，变量的类型在编译时确定，并且严格的类型系统可以在编译时就发现大部分错误。类型在Go语言中是非常重要的，它定义了值的行为和内存布局。

#### 变量声明

Go语言中的变量需要声明后才能使用，同一作用域内不支持重复声明。并且Go语言的变量声明后必须使用。

#### 标准声明

Go语言的变量声明格式为：

```go
var 变量名 变量类型
```

变量声明以关键字`var`开头，变量类型放在变量的后面，行尾无需分号。 举个例子：

```go
var name string
var age int
var isOk bool
```

#### 批量声明

每声明一个变量就需要写`var`关键字会比较繁琐，go语言中还支持批量变量声明：

```go
var (
    a string
    b int
    c bool
    d float32
)
```

#### 变量的初始化

Go语言在声明变量的时候，会自动对变量对应的内存区域进行初始化操作。每个变量会被初始化成其类型的默认值，例如： 整型和浮点型变量的默认值为0。 字符串变量的默认值为空字符串。 布尔型变量默认为`false`。 切片、函数、指针变量的默认为`nil`。

也可在声明变量的时候为其指定初始值。变量初始化的标准格式如下：

```go
var 变量名 类型 = 表达式
```

举个例子：

```go
var name string = "pprof.cn"
var sex int = 1
```

或者一次初始化多个变量

```go
var name, sex = "pprof.cn", 1
```

#### 类型推导

有时候会将变量的类型省略，这个时候编译器会根据等号右边的值来推导变量的类型完成初始化。

```go
var name = "pprof.cn"
var sex = 1
```

#### 短变量声明

在函数内部，可以使用更简略的`` := ``方式声明并初始化变量。

```go
package main

import (
    "fmt"
)
// 全局变量m
var m = 100

func main() {
    n := 10
    m := 200 // 此处声明局部变量m
    fmt.Println(m, n)
}
```

#### 匿名变量

在使用多重赋值时，如果想要忽略某个值，可以使用`匿名变量（anonymous variable）`。 匿名变量用一个下划线``_``表示，例如：

```go
func foo() (int, string) {
    return 10, "Q1mi"
}
func main() {
    x, _ := foo()
    _, y := foo()
    fmt.Println("x=", x)
    fmt.Println("y=", y)
}
```

匿名变量不占用命名空间，不会分配内存，所以匿名变量之间不存在重复声明。 (在Lua等编程语言里，匿名变量也被叫做哑元变量。)

注意事项：

- 函数外的每个语句都必须以关键字开始（var、const、func等）

- ``:=``不能使用在函数外。
- ``_``多用于占位，表示忽略值。

### 常量

相对于变量，常量是恒定不变的值，多用于定义程序运行期间不会改变的那些值。 常量的声明和变量声明非常类似，只是把`var`换成了`const`，常量在定义的时候必须赋值。

```go
const pi = 3.1415
const e = 2.7182
```

声明了`pi`和`e`这两个常量之后，在整个程序运行期间它们的值都不能再发生变化了。

多个常量也可以一起声明：

```go
const (
    pi = 3.1415
    e = 2.7182
)
```

`const`同时声明多个常量时，如果省略了值则表示和上面一行的值相同。 例如：

```go
const (
    n1 = 100
    n2
    n3
)
```

上面示例中，常量`n1、n2、n3`的值都是`100`。

### iota

**`iota`是`go`语言的常量计数器，只能在常量的表达式中使用。**

`iota`在`const`关键字出现时将被重置为`0`。`const`中每新增一行常量声明将使`iota`计数一次(`iota`可理解为`const`语句块中的行索引)。 使用`iota`能简化定义，**在定义枚举时很有用**。

举个例子：

```go
const (
    n1 = iota //0
    n2        //1
    n3        //2
    n4        //3
)
```

### 几个常见的iota示例

### 几个常见的iota示例:使用_跳过某些值

```go
const (
    n1 = iota //0
    n2        //1
    _
    n4        //3
)
```

`iota`声明中间插队

```go
const (
    n1 = iota //0
    n2 = 100  //100
    n3 = iota //2
    n4        //3
)
const n5 = iota //0
```

定义数量级 （这里的`<<`表示左移操作，`1<<10`表示将`1`的二进制表示向左移`10`位，也就是由`1`变成了`10000000000`，也就是十进制的`1024`。同理`2<<2`表示将`2`的二进制表示向左移`2`位，也就是由`10`变成了`1000`，也就是十进制的`8`。）

```go
const (
    _  = iota
    KB = 1 << (10 * iota)
    MB = 1 << (10 * iota)
    GB = 1 << (10 * iota)
    TB = 1 << (10 * iota)
    PB = 1 << (10 * iota)
)
```

多个`iota`定义在一行

```go
const (
    a, b = iota + 1, iota + 2 //1,2
    c, d                      //2,3
    e, f                      //3,4
)
```

## 运算符

### 算术运算符

| 运算符 | 描述 |
| :----- | :--- |
| +      | 相加 |
| -      | 相减 |
| *      | 相乘 |
| /      | 相除 |
| %      | 求余 |

注意： ++（自增）和–（自减）在Go语言中是单独的语句，并不是运算符。

### 关系运算符

| 运算符 | 描述                                                         |
| :----- | :----------------------------------------------------------- |
| ==     | 检查两个值是否相等，如果相等返回 True 否则返回 False。       |
| !=     | 检查两个值是否不相等，如果不相等返回 True 否则返回 False。   |
| >      | 检查左边值是否大于右边值，如果是返回 True 否则返回 False。   |
| >=     | 检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。 |
| <      | 检查左边值是否小于右边值，如果是返回 True 否则返回 False。   |
| <=     | 检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。 |

### 逻辑运算符

| 运算符 | 描述                                                         |
| :----- | :----------------------------------------------------------- |
| &&     | 逻辑 AND 运算符。 如果两边的操作数都是 True，则为 True，否则为 False。 |
| ll     | 逻辑 OR 运算符。 如果两边的操作数有一个 True，则为 True，否则为 False。 |
| !      | 逻辑 NOT 运算符。 如果条件为 True，则为 False，否则为 True。 |

### 位运算符

位运算符对整数在内存中的二进制位进行操作。

| 运算符 | 描述                                                         |
| :----- | :----------------------------------------------------------- |
| &      | 参与运算的两数各对应的二进位相与。（两位均为1才为1）         |
| l      | 参与运算的两数各对应的二进位相或。（两位有一个为1就为1）     |
| ^      | 参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。（两位不一样则为1） |
| <<     | 左移n位就是乘以2的n次方。“a<<b”是把a的各二进位全部左移b位，高位丢弃，低位补0。 |
| >>     | 右移n位就是除以2的n次方。“a>>b”是把a的各二进位全部右移b位。  |

### 赋值运算符

| 运算符 | 描述                                           |
| :----- | :--------------------------------------------- |
| =      | 简单的赋值运算符，将一个表达式的值赋给一个左值 |
| +=     | 相加后再赋值                                   |
| -=     | 相减后再赋值                                   |
| *=     | 相乘后再赋值                                   |
| /=     | 相除后再赋值                                   |
| %=     | 求余后再赋值                                   |
| <<=    | 左移后赋值                                     |
| >>=    | 右移后赋值                                     |
| &=     | 按位与后赋值                                   |
| l=     | 按位或后赋值                                   |
| ^=     | 按位异或后赋值                                 |

## 基本类型

### 简介

Golang 更明确的数字类型命名，支持 Unicode，支持常用数据结构。

| 类型          | 长度(字节) | 默认值 | 说明                                      |
| :------------ | :--------- | :----- | :---------------------------------------- |
| bool          | 1          | false  |                                           |
| byte          | 1          | 0      | uint8                                     |
| rune          | 4          | 0      | Unicode Code Point, int32                 |
| int, uint     | 4或8       | 0      | 32 或 64 位                               |
| int8, uint8   | 1          | 0      | -128 ~ 127, 0 ~ 255，byte是uint8 的别名   |
| int16, uint16 | 2          | 0      | -32768 ~ 32767, 0 ~ 65535                 |
| int32, uint32 | 4          | 0      | -21亿~ 21亿, 0 ~ 42亿，rune是int32 的别名 |
| int64, uint64 | 8          | 0      |                                           |
| float32       | 4          | 0.0    |                                           |
| float64       | 8          | 0.0    |                                           |
| complex64     | 8          |        |                                           |
| complex128    | 16         |        |                                           |
| uintptr       | 4或8       |        | 以存储指针的 uint32 或 uint64 整数        |
| array         |            |        | 值类型                                    |
| struct        |            |        | 值类型                                    |
| string        |            | ""     | UTF-8 字符串                              |
| slice         |            | nil    | 引用类型                                  |
| map           |            | nil    | 引用类型                                  |
| channel       |            | nil    | 引用类型                                  |
| interface     |            | nil    | 接口                                      |
| function      |            | nil    | 函数                                      |

支持八进制、 六进制，以及科学记数法。标准库 math 定义了各数字类型取值范围。

```go
a, b, c, d := 071, 0x1F, 1e9, math.MinInt16
```

空指针值 nil，而非C/C++ NULL。

### 整型

整型分为以下两个大类： 按长度分为：`int8`、`int16`、`int32`、`int64`对应的无符号整型：`uint8`、`uint16`、`uint32`、`uint64`

其中，`uint8`就是熟知的`byte`型，`int16`对应C语言中的`short`型，`int64`对应C语言中的`long`型。

### 浮点型

Go语言支持两种浮点型数：`float32`和`float64`。这两种浮点型数据格式遵循`IEEE 754`标准： `float32` 的浮点数的最大范围约为`3.4e38`，可以使用常量定义：`math.MaxFloat32`。 `float64` 的浮点数的最大范围约为 `1.8e308`，可以使用一个常量定义：`math.MaxFloat64`。

### 复数

`complex64`和`complex128`，复数有实部和虚部，`complex64`的实部和虚部为32位，`complex128`的实部和虚部为64位。

### 布尔值

Go语言中以`bool`类型进行声明布尔型数据，布尔型数据只有`true（真）`和`false（假）`两个值。

注意：

- 布尔类型变量的默认值为false。

- Go 语言中不允许将整型强制转换为布尔型.

- 布尔型无法参与数值运算，也无法与其他类型进行转换。

### 字符串

Go语言中的字符串以原生数据类型出现，使用字符串就像使用其他原生数据类型`（int、bool、float32、float64 等）`一样。 Go 语言里的字符串的内部实现使用 UTF-8 编码。 字符串的值为双引号(")中的内容，可以在Go语言的源码中直接添加非`ASCII`码字符，例如：

```go
s1 := "hello"
s2 := "你好"
```

### 字符串转义符

Go 语言的字符串常见转义符包含回车、换行、单双引号、制表符等，如下表所示。

| 转义 | 含义                               |
| :--- | :--------------------------------- |
| \r   | 回车符（返回行首）                 |
| \n   | 换行符（直接跳到下一行的同列位置） |
| \t   | 制表符                             |
| '    | 单引号                             |
| "    | 双引号                             |
| \    | 反斜杠                             |

举个例子，我们要打印一个Windows平台下的一个文件路径：

```go
package main
import (
    "fmt"
)
func main() {
    fmt.Println("str := \"c:\\pprof\\main.exe\"")
}
```

### 多行字符串

Go语言中要定义一个多行字符串时，就必须使用`反引号`字符：

```go
s1 := `第一行
第二行
第三行
`
fmt.Println(s1)
```

反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出。

### 字符串的常用操作

| 方法                                 | 介绍           |
| :----------------------------------- | :------------- |
| len(str)                             | 求长度         |
| +或fmt.Sprintf                       | 拼接字符串     |
| strings.Split                        | 分割           |
| strings.Contains                     | 判断是否包含   |
| strings.HasPrefix、strings.HasSuffix | 前缀/后缀判断  |
| strings.Index()、strings.LastIndex() | 子串出现的位置 |
| strings.Join(a[]string, sep string)  | join操作       |

### byte和rune类型

组成每个字符串的元素叫做“字符”，可以通过遍历或者单个获取字符串元素获得字符。 字符用单引号（’）包裹起来，如：

```go
var a := '中'

var b := 'x'
```

Go 语言的字符有以下两种：

- uint8类型，或者叫 byte 型，代表了ASCII码的一个字符。

- rune类型，代表一个 UTF-8字符。

当需要处理中文、日文或者其他复合字符时，则需要用到`rune`类型。`rune`类型实际是一个`int32`。
Go 使用了特殊的 `rune` 类型来处理 `Unicode`，让基于 `Unicode`的文本处理更为方便，也可以使用 `byte` 型进行默认字符串处理，性能和扩展性都有照顾。

```go
// 遍历字符串
func traversalString() {
    s := "pprof.cn博客"
    for i := 0; i < len(s); i++ { //byte
        fmt.Printf("%v(%c) ", s[i], s[i])
    }
    fmt.Println()
    for _, r := range s { //rune
        fmt.Printf("%v(%c) ", r, r)
    }
    fmt.Println()
}
```

输出：

```
112(p) 112(p) 114(r) 111(o) 102(f) 46(.) 99(c) 110(n) 229(å) 141() 154() 229(å) 174(®) 162(¢)
112(p) 112(p) 114(r) 111(o) 102(f) 46(.) 99(c) 110(n) 21338(博) 23458(客)
```

因为 UTF8 编码下一个中文汉字由`3~4`个字节组成，所以我们不能简单的按照字节去遍历一个包含中文的字符串，否则就会出现上面输出中第一行的结果。

字符串底层是一个byte数组，所以可以和[]byte类型相互转换。字符串是不能修改的 字符串是由byte字节组成，所以字符串的长度是byte字节的长度。 rune类型用来表示utf8字符，一个rune字符由一个或多个byte组成。

### 修改字符串

要修改字符串，需要先将其转换成`[]rune或[]byte`，完成后再转换为`string`。**无论哪种转换，都会重新分配内存，并复制字节数组。**

```go
func changeString() {
    s1 := "hello"
    // 强制类型转换
    byteS1 := []byte(s1)
    byteS1[0] = 'H'
    fmt.Println(string(byteS1))

    s2 := "博客"
    runeS2 := []rune(s2)
    runeS2[0] = '狗'
    fmt.Println(string(runeS2))
}
```

### 类型转换

Go语言中只有强制类型转换，没有隐式类型转换。该语法只能在两个类型之间支持相互转换的时候使用。

强制类型转换的基本语法如下：

```go
T(表达式)
```

其中，T表示要转换的类型。表达式包括变量、复杂算子和函数返回值等。

比如计算直角三角形的斜边长时使用math包的Sqrt()函数，该函数接收的是float64类型的参数，而变量a和b都是int类型的，这个时候就需要将a和b强制类型转换为float64类型。

```go
func sqrtDemo() {
    var a, b = 3, 4
    var c int
    // math.Sqrt()接收的参数是float64类型，需要强制转换
    c = int(math.Sqrt(float64(a*a + b*b)))
    fmt.Println(c)
}
```

## 数组Array

### go的数组定义

在Go语言中，数组的定义格式为：

```go
var 数组名 [长度]类型
```

例如：

```go
var arr [5]int // 定义一个长度为5的整型数组
```

Go语言数组与其他语言的主要区别有:

1. 数组的长度是数组类型的一部分。``[5]int``和``[10]int``是两种不同的数组类型。
2. 数组一旦定义，其长度就是固定的。不能改变数组的大小。
3. 数组可以存储值的同类型集合。但是每个元素的大小和顺序都是固定的。
4. 数组的值按顺序存储在内存中，数组的第一个元素的内存地址与数组名相同。
5.  数组的大小必须是常量且必须大于零。不能定义``var arr [n]int``这样的数组。
6. 数组是值类型，赋值和传参会复制整个数组。
7.  Go数组的长度是其类型的一部分，所以[5]int和[10]int是不同的类型。

相比而言，其他语言如C/C++的数组：

1. 数组的大小可以是变量。
2.  数组可以动态分配内存，大小可以改变。
3. 数组可以通过指针传参，避免复制整个数组。
4. 数组的类型仅由元素类型决定,与长度无关。``[5]int``和``[10]int``属同一类型数组。

所以，Go语言的数组更加简洁和安全,但缺乏动态能力。而切片在Go中弥补了这一缺陷，具有数组的性能与动态能力。

### 数组初始化

#### 一维数组

在Go语言中,数组的初始化有以下几种方式:

1. 指定初始化值

```go
var arr = [5]int{1, 2, 3, 4, 5}
```

2. 根据初始值的个数自行推断数组长度

```go
var arr = [...]int{1, 2, 3, 4, 5}  // arr为[5]int类型
```

3. 部分初始化,未初始化的默认为零值

```go
var arr = [5]int{1, 2}  // arr为[5]int{1, 2, 0, 0, 0}
```

4. 通过索引初始化

```go
var arr = [5]int{0: 1, 4: 2}  // arr为[5]int{1, 0, 0, 0, 2}
```

5. 通过切片初始化(只初始化部分元素)

```go
var arr = [...]int{0, 0, 0, 0, 0}  
slice := arr[1:3]  // slice为[0, 0]
slice[0] = 1        // arr为[0, 1, 0, 0, 0] 
```

6. 构造函数初始化

```go
var arr = [5]int{}     // arr为[5]int{0, 0, 0, 0, 0}
var arr = new([5]int)   // arr为*[5]int,指向一个值为[5]int{0, 0, 0, 0, 0}的数组 
```

> 内置函数 len 和 cap 都返回数组长度 (元素数量)。

#### 多维数组

在Go语言中，多维数组的初始化方式与一维数组类似，只是需要指定每个维度的长度，格式为：

```go
var 数组名 [维度1长度] [维度2长度]... [维度n长度]类型
```

例如

- 二维数组

```go
var arr [3][4]int   // 二维数组,3行4列
```

- 三维数组

```go
var arr [2][3][4]float64  // 三维数组,2个2维数组,每个2维数组3行4列
```

多维数组的初始化方式有：

1. 指定初始化值

```go
var arr = [3][4]int{ {1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12} }
```

2. 部分初始化,其余默认为零值

```go
var arr = [3][4]int{ {1, 2}, {5, 6}, {9, 10} } 
// arr为[3][4]int{ {1, 2, 0, 0}, {5, 6, 0, 0}, {9, 10, 0, 0} }
```

3. 嵌套切片初始化

```go
var arr = [...][...]int{ {1, 2}, {5, 6}, {9, 10} }  
slice1 := arr[1:2]     // slice1为[][2]int{ {5, 6} } 
slice2 := slice1[0]    // slice2为[2]int{5, 6} 
slice2[1] = 8          // arr为[...][...]int{ {1, 2}, {5, 8}, {9, 10} }
```

4. 构造函数初始化

```go
var arr = [3][4]int{}   // 所有元素默认为0
var arr = new([3][4]int) // 同上,指向数组的指针
```

#### 多维数组遍历

1. 一层一层遍历:

```go
var arr = [2][3]int{ {1, 2, 3}, {4, 5, 6} }

for i := 0; i < 2; i++ {   // 遍历数组的第一维
    for j := 0; j < 3; j++ { // 遍历数组的第二维
        fmt.Print(arr[i][j], " ") 
    }
}  // 输出:1 2 3 4 5 6 
```

2. 嵌套for循环遍历:

```go
for _, v1 := range arr {   // 遍历第一维
    for _, v2 := range v1 { // 遍历第二维
        fmt.Print(v2, " ")
    }
}
```

### 数组拷贝和传参

在Go语言中，数组是值类型，赋值和传参会复制整个数组。这意味着：

1. 数组赋值

```go
var arr1 = [3]int{1, 2, 3} 
var arr2 [3]int
arr2 = arr1   // 数组赋值，arr2为[3]int{1, 2, 3}，arr1不变
```

2. 数组传参

```go
func modify(arr [3]int) {
    arr[0] = 100   // 修改副本的值
} 

func main() {
    var arr [3]int = [3]int{1, 2, 3}  
    modify(arr)
    fmt.Println(arr)  // 输出[1 2 3],原数组未变
} 
```

**在函数调用时，实参arr会复制一份给形参arr，在函数内操作的都是副本，不会影响原数组。**

3. 使用指针传参避免复制

```go
func modify(arr *[3]int) {
    (*arr)[0] = 100   // 修改指针指向的原数组
}

func main() {
    var arr [3]int = [3]int{1, 2, 3}
    modify(&arr)
    fmt.Println(arr)  // 输出[100 2 3]
} 
```

使用指针实参，可以在函数内操作指针指向的原数组，避免数组复制。所以，总结如下：

1. **数组是值类型，赋值和传参会复制整个数组。**
2. **在函数内部操作数组副本，不会影响原数组。**
3. **使用指针传参，可以操作指针指向的原数组，避免数组复制。**
4. **若函数需要操作原数组，必须使用指针类型的形参。**
5. **若在函数内需要返回修改后的数组，必须传递指针。**

## 切片Slice

### 什么是切片

切片(Slice)是Go语言中一个核心的概念。它是对数组的抽象,包含三个信息：

1. 指向数组的指针：切片并不存储任何数据,它只是对数组的引用。
2. 长度：表示切片中元素的数量。
3. 容量：表示从切片开始算起底层数组中元素的数量。

可以简单理解为：切片是 Go 语言动态数组实现的一种方式。它通过对数组的引用来实现动态性和效率。

切片的定义需要指定元素类型，可以选择指定长度，若不指定则默认为 nil 。 切片的长度可以动态变化，容量会自动扩展。

### 切片的特点

切片(Slice)是对数组的抽象，它包括：

1. 切片并不存储任何数据，它只是对现有数组的引用。

2. 切片的定义需要指定元素类型，但是长度和容量是可选的，并且可以根据需要动态变化。

3. 切片的底层数组可以无限扩展，因此切片的容量可以根据需要动态变化。

4. 切片的使用可以节省内存空间，因为它可以引用底层数组的一部分空间。

5. 切片使得Go语言拥有像动态类型语言类似的灵活性和便捷性。

### 切片的定义

在Go语言中,切片的定义方式有以下几种：

1. 不指定长度和容量

```go
var slice []int 
```

这种定义方式会创建一个nil切片，长度和容量都为0。

2. 指定初始值

```go
slice := []int{1, 2, 3}
```

这种方式会创建一个长度和容量都为3的切片，底层引用同一数组。

3. 使用make函数指定长度和容量

```go
slice := make([]int, 3, 5) 
```

这种方式创建一个长度为3，容量为5的切片。

4. 从数组或其他切片截取

```go
arr := [5]int{1, 2, 3, 4, 5}
slice := arr[1:3]     // 截取下标1到2的元素,创建一个长度2,容量4的切片
```

这种方式创建的切片会引用原数组。

5. 组合多个定义方式

```go
slice := make([]int, 0, 5) 
slice = append(slice, 1, 2, 3)   // 长度为3,容量为5的切片
slice = slice[1:]                // 截取下标1到底,创建一个长度2,容量4的切片
```

### 切片的常见操作

切片的常见操作主要包括：

1. append操作：用于向切片追加元素，切片的长度和容量会增加。

```go
slice = append(slice, 1)     // 追加1个元素
slice = append(slice, 2, 3) // 追加2个元素2, 3
```

2. 切片操作：用于从切片中获取子切片，不影响原切片。

```go
slice[start:end]     // 取下标从start到end-1的元素 
slice[start:]        // 取下标从start到底的元素
slice[:end]          // 取下标从头到end-1的元素
slice[:]             // 取整个切片
```

3. len()函数：用于获取切片的长度。

```go
len(slice) 
```

4. cap()函数：用于获取切片的容量。

```go
cap(slice)
```

5. for range遍历：用于迭代切片的元素。

```go
for i, v := range slice {
    // i 为索引,v 为值
}
```

6. 使用copy()函数复制切片：会复制切片中的元素到另一个切片。

> copy ：函数 copy 在两个 slice 间复制数据，复制长度以 len 小的为准。两个 slice 可指向同一底层数组，允许元素区间重叠。

```go
dst := make([]int, 3)       // 长度为3的切片 
copy(dst, src)             // 从src复制3个元素到dst
copy(dst, src[:2])        // 只从src复制2个元素到dst
```

7. 使用nil与 lens、cap比较判断切片是否为空。

```go
var slice []int   // 长度和容量为0的nil切片
if slice == nil {   // 切片是nil
    ...
}
if len(slice) == 0 {   // 切片长度为0
    ... 
}
if cap(slice) == 0 {   // 切片容量为0
    ...
}
```

###  append扩容原理

append函数对切片的扩容规则如下：

1. 如果切片的容量足够，直接追加元素，长度增加1，容量不变。

2.  如果切片的容量不足，进行扩容。**扩容规则是：申请一个新的更大的数组，并将原数组的元素拷贝到新数组，切片引用新数组，废弃原数组**。

   - 新容量=旧容量*2，即每次扩容后容量变为原来的2倍。

   - 新容量不小于需要追加的元素个数。

   - 新容量不超过最大容量，最大容量为int类型的最大值。

3. 追加元素后，切片的长度增加，容量可能增加。

所以，append函数通过扩容来确保切片有足够的容量来存放新的元素。扩容会申请新的更大数组，并拷贝原数组的元素过去。

### make方法

#### 通过make来创建切片

使用make()函数可以创建切片，语法如下:

```go
slice := make([]type, size, cap)
```

- type：切片元素的类型。
- size：切片的长度。
- cap：切片的容量，可选，省略时默认与 size 相同。例如：

```go
slice := make([]int, 3)   // 创建长度为3,容量为3的切片
slice := make([]int, 0, 5) // 创建长度为0,容量为5的切片 
```

使用make()函数创建切片有以下优点:

1. 指定切片的长度和容量，创建所需空间。
1. 切片创建时底层数组就会被创建，不需要再扩容，访问性能更高。
1. 由于底层数组已经创建，可以直接对切片元素进行初始化。

例如:

```go
slice := make([]int, 3, 5)
slice[0] = 100  
slice[1] = 200
```

4. 创建nil切片需要额外判断切片长度，使用make()可以直接创建所需空间的切片，使用更方便。

所以，总结如下：

- 使用make()函数可以指定创建切片的长度和容量。
- 使用make()创建的切片底层数组会直接创建，访问性能更高，不需要再扩容。
- 可以直接对切片元素进行初始化。
- 创建nil切片需要判断长度，使用make()更方便。

#### 为什么通过make创建切片

使用make()函数创建切片有以下重要原因:

1. **方便初始化切片元素**。直接使用make()创建的切片，其底层数组会在创建时就被初始化，所以可以直接对切片元素进行赋值。例如：

```
go
slice := make([]int, 3)
slice[0] = 100 
slice[1] = 200
```

如果使用切片表达式的方式创建，则不能直接初始化元素，会报错。

2. **避免扩容**。使用make()指定切片长度时，切片的底层数组容量就被创建，不需要扩容。而使用切片表达式的方式，在append时可能导致扩容，影响性能。
2. **避免判断切片长度**。创建nil切片后，在访问前需要判断长度是否为0，使用make()可以直接创建所需长度的切片，使用更方便。
2. **指定切片的容量。**使用make()可以在创建时就指定切片的容量，而切片表达式的方式无法指定容量。举例:

```go
// make()方式
slice := make([]int, 3, 5) 

// 切片表达式方式
var slice []int
slice = append(slice, 1)   // 首次append会创建长度和容量都为1的切片
slice = append(slice, 2)   // 此次append会导致扩容 

// 判断nil切片
var slice []int
if slice == nil {   // 需要判断是否为nil
    slice = make([]int, 3)  // 创建切片 
}
slice[0] = 100   // 直接初始化  
```

所以，总结原因如下：

- 方便初始化切片元素。
- 避免在append时导致扩容，提高性能。
- 避免创建nil切片后再判断长度。
- 可以指定切片的容量。

### 切片拷贝

#### 浅拷贝

在Go语言中，copy()函数用于复制切片,语法如下:

```go
copy(dest, src)
```

它会将 src 切片中的元素复制到 dest 切片中，复制的元素个数是两个切片的长度较小的那个。例如:

```go
src := []int{1, 2, 3} 
dest := make([]int, 2)  // len=2, cap=2

copy(dest, src)   // dest变为[1, 2]
```

**copy()函数进行的是浅拷贝**，意味着：

1. **只会复制切片中的元素，不会复制底层数组。两个切片的底层数组仍是同一个数组。**
2. **如果元素是引用类型，拷贝的只是引用，两个切片的对应元素会共享同一块内存。**

举例：

```go
type Person struct{}

p1 := Person{}
src := []Person{p1}  
dest := make([]Person, 1)

copy(dest, src) 

src[0].Name = "p1"  // dest[0]也被修改了  
```

 深拷贝意味着不但会复制切片元素，还会复制底层数组,两个切片拥有独立的内存空间。要实现深拷贝，可以：

1. 重新创建一个切片，追加src的所有元素。

```go
src := []int{1, 2, 3}
dest := []int{}
dest = append(dest, src...)  
```

2. 使用copy()函数先进行浅拷贝，再创建一个新切片作为底层数组。

```go
src := []int{1, 2, 3}
dest := make([]int, len(src))
copy(dest, src)

newSrc := make([]int, len(src)) 
copy(newSrc, dest)  // 此时newSrc底层数组为新的数组 
```

#### 深拷贝

在Go语言中，要实现切片的深拷贝，有两种主要方式：

1. 创建一个新的切片，并使用append()函数追加所有元素

```go
src := []int{1, 2, 3}
dest := []int{}
dest = append(dest, src...)  
```

这种方式会创建一个新的切片，包含全部新元素。两者底层数组不同，修改一个切片不会影响另一个切片。

2. 先使用copy()函数进行浅拷贝，再创建新切片作为底层数组

```go
src := []int{1, 2, 3}
dest := make([]int, len(src)) 
copy(dest, src)

newDest := make([]int, len(src)) 
copy(newDest, dest)   // 此时newDest底层数组为新的数组
```

这种方式，先将源切片src的元素拷贝到dest切片，再创建一个新的切片 newDest，并设置为dest的底层数组，实现深拷贝。

以上两种方式的实现原理是：**创建一个新的底层数组，并将元素值复制过去**。这样，两个切片就拥有独立的内存空间，修改一个切片不会影响另一个切片。所以，深拷贝的关键是创建新的底层数组，并复制元素值。理解slices的底层实现，对掌握深拷贝很重要。

### slice遍历

在Go语言中，切片可以通过以下几种方式进行遍历：

1. for循环遍历

```go
slice := []int{1, 2, 3}
for i := 0; i < len(slice); i++ {
    fmt.Println(slice[i])
} 
```

2. for range遍历

```go
for index, value := range slice {
    fmt.Println(index, value)  
}
```

 range返回两个值，第一个值是当前元素的索引，第二个值是当前元素的值。

3. 使用切片表达式迭代

```go
for _, value := range slice[:] {
    fmt.Println(value)
} 
```

这种方式在每次迭代中生成一个包含剩余元素的新切片，直到切片为空。

4. 使用copy方法拷贝迭代

```go
newSlice := make([]int, len(slice))
copy(newSlice, slice)

for i := 0; i < len(newSlice); i++ {
    fmt.Println(newSlice[i])  
}
```

这种方式可以完全避免迭代时的扩容，因为操作的是一个新的切片副本。

### 切片resize（调整大小）

在Go语言中，切片的大小可以通过内置的resize()函数进行调整，语法为：

```go
slice = slice[:new_len]
```

这种方式可以扩展或缩短切片的长度。如果新长度大于切片的容量，切片会按比例进行扩容。例如：

```go
slice := []int{1, 2, 3}   // len=3, cap=3

slice = slice[:4]         // len=4, cap=6, slice变为[1 2 3 0]
slice = slice[:2]         // len=2, cap=6, slice变为[1 2]
```

所以，resize()函数可以：

1. 扩展切片的长度，超出容量会触发扩容，新增元素用零值填充。
2.  缩短切片的长度，超出的元素会被移除。 capacity不变。
3. capacity的变化规律遵循切片扩容规则，每次扩容后至少扩大一倍。

使用resize()时需要注意：

1. 不能超过切片底层数组的最大长度,否则会panic。
2. 可能会导致append造成的扩容。如果先append后resize，中间可能出现扩容。
3. 不会修改底层数组大小,只会修改切片的长度和容量属性。底层数组会保留多余空间。
4. 不能再使用resize()缩短切片到原始长度之前,已有的多余空间不会释放。

所以，总结如下：

- resize()函数可以扩展或缩短切片的长度。
- 超出容量会触发扩容，新元素置零值。缩短长度不会减小容量。
- capacity的增长遵循切片扩容规则，每次至少扩大一倍。
- 注意不要超出底层数组最大长度，可能导致append造成的扩容,不会修改底层数组大小，已扩容的空间不会释放。

### 字符串和切片（string and slice）

#### 字符串与切片的关系

在Go语言中，字符串是由[]byte或[]rune构成的只读切片。它包括：

1. `[]byte`类型的字符串

```go
str := "abcdefg"   // str的类型是string,底层是[]byte
```

每个字节 represents 一个ASCII字符。

2. `[]rune`类型的字符串

```go
str := "编码"   // str的类型是string,底层是[]rune
```

每个rune represents 一个UTF-8字符。字符串如同只读切片一样，支持切片操作：

```go
str[0]      // byte类型的字符串访问第一个字节
str[1:3]    // 取下标1到3的子字符串 
len(str)    // 获取字符串长度,以字节或字符计
```

但是字符串不支持使用append、resize等函数修改内容，因为它是只读的。字符串可以转换为``[]byte``或``[]rune``类型的只读切片：

```go
bytes := []byte("abc")
runes := []rune("编码")
```

反之，``[]byte``和``[]rune``也可以转换为string：

```go
str = string([]byte{'a', 'b', 'c'})  
str = string([]rune{'编', '码'})
```

所以，字符串其实是一种特殊的只读切片，它包括：

- `[]byte`类型的字符串，每个字节代表一个ASCII码。
- `[]rune`类型的字符串，每个rune代表一个UTF-8字符。

字符串支持和只读切片相同的切片操作，但是不支持修改内容的函数如append和resize。字符串可以转换为``[]byte``或``[]rune``类型的只读切片，反之[]byte和[]rune也可以转换为string。

#### 如何操作字符串

由于字符串是不可变的,如果需要对字符串进行修改，有以下几种方式：

1. 转换为[]byte或[]rune，操作切片，再转换回string

```go
str := "abc"
bytes := []byte(str) 
bytes[0] = 'd'   // 修改切片
str = string(bytes) // 转换回string
```

2. 使用 bytes.Buffer 或 strings.Builder 进行操作:

```go
var buffer bytes.Buffer
buffer.WriteString("abc") 
buffer.WriteByte('d')      // 追加字节
str := buffer.String()      // 转换为string // abcd
```

3. 重新分配并复制整个字符串:

```go
newStr := str[:2] + "d" + str[3:]  // 重新分配并复制部分字符
str = newStr                       // str变为"abdd"
```

4. 使用+拼接多个字符串:

```go
str := "ab" + "d" + "c"   // str变为abcd
```

5. 格式化字符串:

```go
str := fmt.Sprintf("%s%c%s", "ab", 'd', "c") // str变为abcd
```

所以，总结如下：字符串是不可变的，但可以通过转换为切片、使用缓冲区、重新分配复制、拼接或格式化字符串等方式进行修改。

### Slice底层实现

#### 概述

切片是 Go 中的一种基本的数据结构，使用这种结构可以用来管理数据集合。切片的设计想法是由动态数组概念而来，为了开发者可以更加方便的使一个数据结构可以自动增加和减少。但是切片本身并不是动态数据或者数组指针。切片常见的操作有 reslice、append、copy。与此同时，切片还具有可索引，可迭代的优秀特性。

#### 切片和数组

首先，关于切片和数组怎么选择？接下来好好讨论讨论这个问题。

在Go语言中，选择切片和数组主要根据以下几点考虑：

1. 数据量大小是否固定：如果数据量大小固定，可以选择数组；如果数据量大小不固定，需要动态变化，则选择切片。切片的长度和容量都是可变的，可以根据需要动态变化；数组的长度是固定的,在定义时确定。
2.  是否需要频繁添加删除元素：如果需要频繁添加删除元素，选择切片；如果大部分时间只读或只在初始化时填充，选择数组。切片支持使用append Dynamic加入元素，删除元素只需要修改长度；数组的长度固定，无法添加删除元素。
3.  空间和性能考虑：如果数据量较小，空间和性能要求不高，二者皆可；如果数据量较大，空间和性能至关重要，数组更占优。切片在append时可能需要扩容copy，影响性能；数组的空间在定义时就分配，性能更高。
4. 使用场景：切片适合 stack、queue、list等动态数据结构；数组更适合表，映射等需要快速随机访问的场景。

所以，总结选择标准为：

1. **数据量大小是否固定：固定选择数组，可变选择切片。**
2. **是否频繁添加删除：是选择切片，否选择数组。**
3. **空间和性能：数据小无所谓，数据大数组更优。**
4. **使用场景：栈、队列、链表选切片；映射、表选数组。**

理解二者的区别与适用场景，可以让我们在开发中更精确的选择切片或数组。切片实现了动态数组，扩展了数组的灵活性；数组具有更高的空间和性能效率。

#### 切片的数据结构

切片本身并不是动态数组或者数组指针。它内部实现的数据结构通过指针引用底层数组，设定相关属性将数据读写操作限定在指定的区域内。切片本身是一个只读对象，其工作机制类似数组指针的一种封装。

切片的结构定义如下：

```go
type slice struct {
    array unsafe.Pointer  
    len   int
    cap   int 
}
```

切片的结构体由3部分构成，Pointer 是指向一个数组的指针，len 代表当前切片的长度，cap 是当前切片的容量。cap 总是大于等于 len 的。

- array是指向底层数组的指针，切片不直接存储数据，它只是引用底层数组的一段连续内存区域。
- len表示当前可以访问的元素数量，cap表示从slice开始最大可以访问的元素数量。
- len和cap控制着我们对底层数组的访问窗口，可以动态变化。

#### 内存地址与slice

如果想从 slice 中得到一块内存地址，可以这样做：

```go
s := make([]byte, 200)
ptr := unsafe.Pointer(&s[0])
```

如果反过来呢？从 Go 的内存地址中构造一个 slice。

```go
var ptr unsafe.Pointer
var s1 = struct {
    addr uintptr
    len int
    cap int
}{ptr, length, length}
s := *(*[]byte)(unsafe.Pointer(&s1))
```

构造一个虚拟的结构体，把 slice 的数据结构拼出来。

当然还有更加直接的方法，在 Go 的反射中就存在一个与之对应的数据结构 SliceHeader，可以用它来构造一个 slice。

```go
var o []byte
sliceHeader := (*reflect.SliceHeader)((unsafe.Pointer(&o)))
sliceHeader.Cap = length
sliceHeader.Len = length
sliceHeader.Data = uintptr(ptr)
```

如果反过来呢？从 Go 的内存地址中构造一个 slice。

```go
var ptr unsafe.Pointer
var s1 = struct {
    addr uintptr
    len int
    cap int
}{ptr, length, length}
s := *(*[]byte)(unsafe.Pointer(&s1))
```

构造一个虚拟的结构体，把 slice 的数据结构拼出来。

当然还有更加直接的方法，在 Go 的反射中就存在一个与之对应的数据结构 SliceHeader，我们可以用它来构造一个 slice

```go
var o []byte
sliceHeader := (*reflect.SliceHeader)((unsafe.Pointer(&o)))
sliceHeader.Cap = length
sliceHeader.Len = length
sliceHeader.Data = uintptr(ptr)
```

#### 如何创建的切片

##### 概述

make 函数允许在运行期动态指定数组长度，绕开了数组类型必须使用编译期常量的限制。

创建切片有两种形式，make 创建切片，空切片。

##### make 创建切片

make函数会根据传入的len和cap来创建切片

```go
func makeslice(et *_type, len, cap int) slice {
    
    // 检查len和cap是否在允许范围内
    
    // 根据切片的数据类型，获取切片的最大容量
    maxElements := maxSliceCap(et.size)
    // 比较切片的长度，长度值域应该在[0,maxElements]之间
    if len < 0 || uintptr(len) > maxElements {
        panic(errorString("makeslice: len out of range"))
    }
    // 比较切片的容量，容量值域应该在[len,maxElements]之间
    if cap < len || uintptr(cap) > maxElements {
        panic(errorString("makeslice: cap out of range"))
    }
    
    
    // 使用mallocgc分配一段连续内存
    p := mallocgc(et.size*uintptr(cap), et, true)
    
    // 初始化切片结构体
    slice := slice{p, len, cap}  
    
    // 返回初始化的切片 -- 返回申请好内存的切片的首地址
    return slice
}
```

- 首先检查len和cap是否超出范围,超出会panic。
- 然后使用 mallocgc 分配一段足够容纳cap个元素的内存空间。
- 初始化切片结构体，array指向刚分配的内存空间，len为传入的len，cap为传入的cap。

- 返回初始化后的切片结构体。

所以make函数实现了根据len和cap创建切片，内部调用mallocgc分配内存，并返回一个引用了内存，设置好长度和容量的切片结构体。

这个make函数有什么好处呢？

1. 可以指定切片的初始长度len和容量cap，不需要在使用前判断长度是否为0。
2. 切片创建时底层数组的内存已经分配，不需要再扩容，访问性能会更高。
3. 可以在创建切片时直接初始化元素

##### nil 和空切片

在Go语言中，nil切片和空切片的定义如下：

nil切片：

```go
var slice []int    // len(slice) = 0, cap(slice) = 0, slice == nil 
```

空切片：

```go
slice := []int{}   // len(slice) = 0, cap(slice) = 0, slice != nil
```

nil切片和空切片的主要区别在于：

- nil切片
  - 切片声明后没有进行初始化，slice == nil
  - len和cap都为0
  - 不能进行任何操作,会报panic

- 空切片：

  - 使用切片表达式 []Type{} 初始化，slice != nil
  - len和cap也为0

  - 可以正常操作，append等函数可以正常使用

那么nil切片和空切片在底层源码中的表示是怎样的呢？

nil切片：nil 切片被用在很多标准库和内置函数中，描述一个不存在的切片的时候，就需要用到 nil 切片。比如函数在发生异常的时候，返回的切片就是 nil 切片。nil 切片的指针指向 nil。

```go
slice {
    array: nil     // 指向底层数组指针为nil
    len:   0      
    cap:   0
}
```

空切片：空切片一般会用来表示一个空的集合。比如数据库查询，一条结果也没有查到，那么就可以返回一个空切片。

```go
slice {
    array: pointer // 指向一个长度为0的底层数组
    len:   0      
    cap:   0 
} 
```

可以看到：

- nil 切片：array为nil,没有底层数组，不能进行任何操作。
- 空切片：array指向一个长度为0的底层数组，可以正常操作。

所以总结得知，空切片和 nil 切片的区别在于，空切片指向的地址不是nil，指向的是一个内存地址，但是它没有分配任何内存空间，即底层元素包含0个元素。

#### 切片如何动态扩容

##### 概述

##### 扩容策略

```go
func growslice(oldPtr unsafe.Pointer, newLen, oldCap, num int, et *_type) slice {
    // oldLen是原slice的长度
    oldLen := newLen - num
    // 用于race检测的,用来检测growslice函数内是否存在数据竞争
    // race检测是Go语言的一个重要特性,用于检测并发程序中的数据竞争。在并发执行时,如果两个goroutine同时访问同一内存地址,且其中一个是写操作,这就可能发生数据竞争。
    if raceenabled {
        callerpc := getcallerpc()
        racereadrangepc(oldPtr, uintptr(oldLen*int(et.size)), callerpc, abi.FuncPCABIInternal(growslice))
    }
    // 用于内存检测(Memory Sanitizer)的,用来检测growslice函数内是否存在未初始化内存的读操作。
    if msanenabled {
        msanread(oldPtr, uintptr(oldLen*int(et.size)))
    }
    // 用于地址无效检测(Address Sanitizer)的,用来检测growslice函数内是否存在访问无效内存地址的读操作。
    if asanenabled {
        asanread(oldPtr, uintptr(oldLen*int(et.size)))
    }

    if newLen < 0 {
        panic(errorString("growslice: len out of range"))
    }

    // 如果元素类型et的大小et.size为0,则返回一个只包含长度和容量都为newLen的空slice。
    if et.size == 0 {
        return slice{unsafe.Pointer(&zerobase), newLen, newLen}
    }
    // 扩容策略
    /*
		当旧容量较小时,新容量以两倍速度增长;
		当旧容量较大时,新容量增长放缓至1.25倍;
		新容量的增长在新长度与内存限制之间进行平衡,避免过快增长导致的问题。
	*/
    newcap := oldCap    // 1. 新容量初值=旧容量 
    doublecap := newcap + newcap   // 2. 旧容量的两倍 
    if newLen > doublecap {     
        newcap = newLen   // 3. 新长度大于旧容量两倍,新容量=新长度
    } else {
        const threshold = 256   // 4. 阈值=256
        if oldCap < threshold {  
            newcap = doublecap   // 5. 旧容量小于阈值,新容量=旧容量两倍
        } else {
            // 6. 检查新容量是否溢出,防止无限循环 
            for 0 < newcap && newcap < newLen { 
                // 7. 新容量增长规则:起初增长两倍,后增长1.25倍
                newcap += (newcap + 3*threshold) / 4   
            }
            // 8. 如果新容量<=0(发生溢出),新容量=新长度
            if newcap <= 0 {   
                newcap = newLen
            }
        }
    } 

    // 计算新的切片的容量，长度。
    /*
    	根据元素类型et.size的不同,选择不同的方式计算切片占用的内存大小
    	- 如果类型大小为1字节,直接用len和newCap计算
        - 如果类型大小等于指针大小,则把len和newCap乘以指针大小
        - 如果类型大小是2的幂,则用位移运算计算
        - 否则,直接把len和newCap乘以类型大小
        同时也会判断新容量是否会溢出 maxAlloc(最大分配内存)。
    */

    var overflow bool 	// 是否溢出
    var lenmem, newlenmem, capmem uintptr // 内存大小
    switch {
        case et.size == 1:   // 类型大小为1字节
        lenmem = uintptr(oldLen)     // 原长度内存
        newlenmem = uintptr(newLen)   // 新长度内存
        capmem = roundupsize(uintptr(newcap))   // 新容量内存
        overflow = uintptr(newcap) > maxAlloc  // 检查是否溢出
        newcap = int(capmem)      // 新容量

        case et.size == goarch.PtrSize: // 与指针大小相同
        lenmem = uintptr(oldLen) * goarch.PtrSize
        newlenmem = uintptr(newLen) * goarch.PtrSize
        capmem = roundupsize(uintptr(newcap) * goarch.PtrSize)
        overflow = uintptr(newcap) > maxAlloc/goarch.PtrSize
        newcap = int(capmem / goarch.PtrSize)

        case isPowerOfTwo(et.size): // 是2的幂
        var shift uintptr
        if goarch.PtrSize == 8 {
            shift = uintptr(sys.TrailingZeros64(uint64(et.size))) & 63
        } else {
            shift = uintptr(sys.TrailingZeros32(uint32(et.size))) & 31
        }
        lenmem = uintptr(oldLen) << shift
        newlenmem = uintptr(newLen) << shift
        capmem = roundupsize(uintptr(newcap) << shift)
        overflow = uintptr(newcap) > (maxAlloc >> shift)
        newcap = int(capmem >> shift)
        capmem = uintptr(newcap) << shift

        default:   // 其它情况
        lenmem = uintptr(oldLen) * et.size  // 原长度内存
        newlenmem = uintptr(newLen) * et.size // 新长度内存

        capmem, overflow = math.MulUintptr(et.size, uintptr(newcap))  // 新容量内存和是否溢出
        capmem = roundupsize(capmem)   // 新容量内存向上round到ptrSize的倍数
        newcap = int(capmem / et.size) // 新容量
        capmem = uintptr(newcap) * et.size  // 新容量内存
    }

   // 如果新容量capmem计算结果溢出或大于最大内存限制maxAlloc,则panic。
    if overflow || capmem > maxAlloc {
        panic(errorString("growslice: len out of range"))
    }

    // 根据元素类型et是否包含指针,选择不同的内存分配方式,并在必要时执行内存屏障操作。
    var p unsafe.Pointer   // 新内存的指针
    if et.ptrdata == 0 {  // 如果不包含指针
        p = mallocgc(capmem, nil, false)  // 分配新内存
        /*
        	- memclrNoHeapPointers:使用memclr函数清理内存,但跳过包含指针的内存区域,这可以避免扫描未初始化的指针内存
			- add(p, newlenmem): p指向新分配的内存,newlenmem是新slice现有数据的内存大小,add(p, newlenmem)跳到新slice现有数据的末尾
			- capmem-newlenmem:新slice的剩余可用内存大小,也是需要清理的内存区域
        */
        memclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem)  // 清理新slice尾部的capmem-newlenmem大小内存,但不包含指针区域,只清理空数据区域
    } else {   // 如果包含指针
        p = mallocgc(capmem, et, true)   // 分配新内存
        // 在向新内存写入数据前,执行内存屏障操作bulkBarrierPreWriteSrcOnly,保证所有对原内存的访问在此之前完成。
        if lenmem > 0 && writeBarrier.enabled {  
            // 在写入新内存区域前,执行内存屏障操作,确保所有对oldPtr的访问在内存回收前完成
            /*
             	- uintptr(p):新内存区域的起始地址
                - uintptr(oldPtr):原内存区域的起始地址
                - lenmem-et.size+et.ptrdata:需要访问的原内存大小,其中:
                    - lenmem:原slice的长度
                    - et.size:元素类型大小
                    - et.ptrdata:元素类型中指针部分的大小
                会在写入新内存p前,执行一次内存屏障操作,强制所有对oldPtr起始地址长度为lenmem-et.size+et.ptrdata的内存区域的访问立即完成。
            */
            bulkBarrierPreWriteSrcOnly(uintptr(p), uintptr(oldPtr), lenmem-et.size+et.ptrdata)
            /*
              	这么做的目的是:
                切片扩容时,会申请新内存并拷贝数据,原内存会在拷贝完成后立即回收。
                如果这时还有针对原内存的未完成访问(读或写),会访问到已回收的内存,产生严重问题。
                所以,在写入新内存前执行内存屏障,可以确保所有对原内存的访问在内存回收前完成,避免访问回收内存的问题。
            */
        }  
    }
    // 将oldPtr指向的内存区域的前lenmem个字节的数据拷贝到p指向的内存区域
    /*
       	- p:目的内存区域的起始地址
        - oldPtr:源内存区域的起始地址
        - lenmem:需要拷贝的内存大小,以字节为单位
    */
    memmove(p, oldPtr, lenmem)
    
    // 返回最终新切片，容量更新为最新扩容之后的容量
    return slice{p, newLen, newcap}
}
```

##### race检测的实现原理

race检测是Go语言的一个重要特性，**用于检测并发程序中的数据竞争**。在并发执行时，如果两个goroutine同时访问同一内存地址，且其中一个是写操作，这就可能发生数据竞争。

race检测的实现原理是：

1. 编译器会在代码中添加race检测相关的逻辑，像上面示例中的那样记录读写操作
2. 程序运行时，会打开一个额外的goroutine来进行检测
3. 每当发生读写操作时，会通过channel与这个goroutine进行通信
4. 该goroutine维护一个映射表，记录每个内存地址的读写状态
5. 当收到读写操作通知时，会检查映射表判断是否存在冲突，如果存在则报告数据竞争的警告
6. 程序结束时，会输出检测报告和统计信息

所以，理解race检测的实现原理，可以让我们在写并发程序时注意避免数据竞争，或者在检测到冲突时进行修复。数据竞争会导致程序产生不一致的行为，所以并发程序的正确性非常重要。

##### 内存屏障的作用

内存屏障的作用：

1. 它可以确保指令重排序不会把内存屏障两边的指令重组在一起，从而影响程序执行的正确性。
2. 它可以强制CPU将对指定内存区域的所有缓存行的写入行为写回到内存，这可以确保其他CPU核心或设备能看到这些写入的数据。
3. 它可以强制发出所有对指定内存区域的读请求，确保读到最新写入的数据，这可以在需要读取最新写入的数据前使用。

所以，理解内存屏障的作用机制，可以让我们在编写并发程序时：
1. 正确使用内存屏障，确保重要的内存访问顺序进行必要的限制，避免重排序导致的问题。
2. 在需要读取最新数据前执行，确保读到最新写入的数据。
3. 在内存回收前执行，确保完成所有相关的内存访问，避免访问回收内存。
4. 根据访问内存区域的不同选择合适的屏障函数，充分利用CPU的特性提高性能。

内存屏障作为一种轻量级的同步机制，比锁的性能损失更低，但能提供必要的同步保证，这点值得我们在设计并发算法时慎重权衡。同时，不同的架构下，内存屏障也有不同的实现与语义，需要具体问题具体分析与选择。

##### memmove的作用

memmove(p, oldPtr,lenmem)的作用是：**将oldPtr指向的内存区域的前lenmem个字节的数据拷贝到p指向的内存区域**。其中：
- p：目的内存区域的起始地址
- oldPtr：源内存区域的起始地址
- lenmem：需要拷贝的内存大小，以字节为单位

memmove是一个内存拷贝函数，它会按从低地址到高地址的顺序拷贝内存数据。和memcpy相比，memmove可以处理源和目的内存区域有重叠的情况。它会先拷贝高地址部分，然后再拷贝低地址部分，保证源数据不被覆盖。而memcpy在内存重叠时行为是未定义的，可能会导致源数据被破坏的问题。

所以，这行代码会将oldPtr起始地址长度为lenmem的内存区域的数据拷贝至p起始地址，即使两区域有重叠，数据也不会被破坏。这么做的原因是：在切片扩容时，mallocgc会重新分配一块更大的内存，并需要将原数据迁移至新内存。在迁移过程中，原内存和新内存的边界可能重叠，如果使用memcpy则可能破坏数据，所以**选择memmove以保证数据的完整性**。

理解memmove的作用，可以让我们在编写涉及内存操作的程序时：
1. 在内存区域有重叠时选择memmove，确保数据不被破坏
2. 根据重叠方式的不同选择拷贝方向，最小化拷贝操作。memmove会从前向后拷贝一次，根据重叠方式拷贝方向不同，效率也会不同。
3. 根据实际需要选择内存拷贝方式，memcpy在无重叠时速度更快，内存拷贝是一个常见但性能敏感的操作，需要仔细权衡。
4. 保证源数据区域在拷贝完成之前一直有效，否则会访问非法内存。
5. 根据系统架构选择最优的内存拷贝实现，如使用SSE2指令可以提高memcpy的性能。

## 指针

### 概述

Go语言中指针用于间接访问内存，与C/C++中的指针有一定差异：
1. Go语言的指针不能进行运算，不能加减或比较，只能进行赋值和==比较操作。这是为了简化指针的语义，避免出现空指针等问题。
2. Go语言没有指针运算，所以没有指针类型，指针是一个uintptr，只有与采用unsafe包进行转换后才可以使用。
3. Go语言GC会自动管理指针的内存回收，不需要手动释放指针占用的内存。
4. Go语言没有指向指针的指针，这是基于内存模型的限制，遍历指针链不如通过slice或map简单高效。

凡是可寻址的类型或者接口的值都有个内存地址，都可以通过 unsafe.Pointer 获取其指针。但反过来，unsafe.Pointer 指针如果要访问目标值，必须确定指针指向的内存中的数据类型。

通过上述对比可以看出，Go语言简化了指针的语义，隐藏了指针的底层运算与unsafe包的使用，这使得Go语言的指针更容易正确使用并且与GC配合。但如果真的需要底层指针操作，Go语言也提供了unsafe包进行支持。

在Go语言中，指针的主要用途是：

1. 访问C函数：unsafe包可以将任意类型转换为指针，用于和C函数交互。
2. 访问共享内存：通过指针可以访问共享内存或映射内存，用于高性能计算。
3. 手动内存管理：通过指针和unsafe可以手动管理内存，当标准库无法满足需求时使用。但这需要非常谨慎，容易导致问题。
4. 反射：reflect包使用指针来访问接口的动态目标类型信息。
5. 特殊数据结构：链表，B树等需要指针支持。但 slice，map已经可以覆盖大部分需求，指针只在性能要求高时使用。

所以总的来说，Go语言的指针更加简单与安全，GC的支持使得指针可以自动管理内存，这使得Go语言更容易上手。但如果真的需要底层控制和性能支撑，通过unsafe包和指针也可以实现。Go语言在提供高层便利的同时，也具有底层控制的能力。

### Go语言中的指针

在Go语言中，通过  ``&``  和  ``*``  操作符可以实现间接访问内存。**``&``用来获取变量的内存地址，返回一个指向该变量的指针。``*``  用来通过指针访问其指向的变量，可以读取或者修改变量的值**。
指针具有以下特点：

1. Go语言中的指针是通过 uintptr 表示的，它是一个可以容纳指针值的整数类型。
2. 指针的值就是内存地址，可以通过类型转换进行操作，但指针不支持运算，只能进行比较和赋值操作。这使得Go语言指针更简单和安全。
3. 指针需要初始化后才能使用，非法指针会导致程序 panic。
4. 指针在使用前需要确保其指向的内存一直有效，否则会访问非法内存。内存管理需要考虑指针的生命周期。
5. 指针可以用于手动内存管理，但需要非常谨慎。Go语言的 GC 会自动回收无用内存，指针使用不当会导致内存泄漏。
6. 指针可以通过类型断言访问接口的动态目标类型信息，这是反射机制的基础。
7. 指针可以用于访问共享内存与C语言交互，这需要通过unsafe包进行。
8. 凡是可寻址的类型都有地址，都可以通过指针访问。但反过来，通过指针能够正确访问的值类型需要和指针本身数据类型严格对应。

除此之外，有几点需要注意：

1. 不同系统架构下指针所占大小可能不同，需要考虑指针的可移植性。
2. C/C++中的指针概念可以作为参考，但Go语言中的指针语义更加简单，不存在指针运算，重载等操作。
3. slice和map已经覆盖了大部分需要动态扩容的场景，指针应该更多作为底层机制的支撑与与C语言交互使用。
4. Go编译器可以对指针进行定界检查，超出范围的指针操作会panic，编译阶段检查可以增强程序的健壮性。

### 指针地址和指针类型

在Go语言中，指针包含两部分信息：

1. 指针地址：存储变量的内存地址，用于定位变量在内存中的位置。

2. 指针类型：``*T``，表示指针指向的变量是T类型。

例如：

```go
var n int = 10
p := &n  // p为n的地址,*int类型
```

**这里 p 的指针地址为 n 变量的内存地址，指针类型为 ``*int``，表示它指向的变量是 int 类型。*代表指针。**

理解指针地址和指针类型，有以下几点需要注意：

1. 指针地址是通过``&``操作符获得，它的值代表变量在内存中的位置，可以通过类型转换为uintptr使用。
2. 指针类型决定了通过该指针可以访问的变量类型与操作，如果类型不匹配会导致程序panic。
3. 指针类型用于编译时进行类型检查，如果指针运算导致指针值超出变量范围，编译器可以发现并报错。
4. 通过指针间接访问变量时，必须确保指针类型与变量类型匹配，否则会访问非法内存或修改变量值失败。
5. 指针地址与变量间的关联是在运行时建立的，如果指针超出变量生命周期继续解引用，会访问非法内存。
6. 相同类型的指针可以比较和赋值，而不同类型的指针之间不支持比较操作。这可避免由于指针运算导致的混乱。
7. 指针类型决定了GC如何跟踪和回收通过指针间接访问的变量，类型不匹配会导致GC失效。
8. 通过类型断言可以访问接口的动态类型信息，它需要使用指针类型进行检查与转换。
9. unsafe包可以把任意类型转换为指针，但反向操作需要显式转换为指针指向的真实类型才可正常使用。
  所以指针地址和指针类型都包含重要的信息，理解它们的关系可以正确而高效地使用指针。Go语言通过指针类型实现了对指针操作的编译时检查，这避免了许多潜在问题，使得指针的使用更加简单与安全。

举个例子，加深印象：

```go
func main() {
    a := 10
    b := &a
    fmt.Printf("a:%d ptr:%p\n", a, &a) // a:10 ptr:0xc00001a078
    fmt.Printf("b:%p type:%T\n", b, b) // b:0xc00001a078 type:*int
    fmt.Println(&b)                    // 0xc00000e018
}
```

来看一下`b := &a`的图示：

![image-20230624142859602](./assets/01-Go基础篇/image-20230624142859602.png)

### 指针取值

在go语言中，可以通过指针进行取值操作，用于读取或修改指针指向变量的值。指针取值有以下几种方式：
1. ``*p``：通过指针 p 解引用读取变量的值。例如：
```go
var n int = 10 // 普通变量
p := &n       // p为n的指针引用
x := *p  // x = 10，读取n的值 -- 通过指针间接访问,此处解引用也为 10 
```

> 注意：【解引用】可以理解为【通过指针直接访问变量】

2. ``*p = value``：通过指针p解引用修改变量的值。例如：

```go
*p = 20  // n = 20，修改n的值 
```
3. `(*p).f`：通过指针p解引用访问结构体变量的字段f。例如：
```go
type T struct{
   f int 
}
t := T{10}
p := &t
x := (*p).f // x = 10， 访问t.f
```

4. `elemType(p)`：将指针p显式转换为 elemType 类型，然后访问变量。例如：
```go
t := (*T)(p)  
x := t.f        // x = 10， 访问t.f
```

5. ``*[N]T(p)``：将指针p显式转换为[N]T类型，然后访问数组变量。例如：
```go 
a := [2]int{1， 2}
p := &a[0]
b :=(*[2]int)(p) // b = [1， 2]
x := b[1]        // x = 2
```

所以指针取值的方式有：
1. 直接通过 ``*p`` 解引用读写变量的值
2. 通过 ``(*p).f`` 的方式访问结构体变量的字段
3. 通过类型断言 `elemType(p)` 将指针转换为真实类型，然后访问变量
4. 通过类型转换 `(*[N]T)(p)` 将指针转换为数组类型，然后访问数组元素
5. 修改指针指向变量的值也可以改变原变量的值

需要注意的是，指针取值前必须确保：

1. 指针非空，否则会panic
2. 指针生命周期包含变量的生命周期，否则访问非法内存
3. 指针类型与变量类型匹配，否则panic
4. 通过类型断言访问接口的动态类型前，必须确定指针的真实类型

### 空指针

在Go语言中，**空指针是一个不能访问任何变量的指针，它的值为空(nil)**。

空指针有以下特点：

1. 空指针的值是nil，可以通过 ``var ptr *T`` 或者 ``ptr := nil`` 初始化。
2. 空指针不可以进行解引用，否则会panic。例如：``*nil`` 会panic。
3. 空指针可以和其他指针进行比较，相等比较结果为true。但不可以直接比较两个nil。
4. 空指针可以赋值给其他指针变量。
5. 通过空指针调用方法会panic，因为没有方法接收者。

空指针的主要用途是：

1. 作为指针类型的零值使用：定义指针变量但暂不初始化为具体地址时使用。
2. 表示某个指针目前未指向任何变量，用于安全判断。
3. 占位使用，当指针指向的变量生命周期结束后，赋值为nil避免取值panic。
4. 与其他指针进行比较，判断是否指向同一变量。

```go
var ptr *int // ptr为nil
ptr = nil

println(ptr == nil) // true
// println(*ptr)       // panic: invalid memory address or nil pointer dereference

p := new(int) // p为int指针
*p = 10
ptr = p
// 使用ptr...
ptr = nil // p生命周期未结束,只是ptr失效

println(p == nil) // false
println(p == ptr) // false, ptr已失效
```

需要注意的是：
1. 空指针不可以进行解引用，否则会panic。
2. 空指针只能与其他指针进行比较，不能直接和nil比较。nil只是一个值，不是指针类型。
3. 空指针可能会暂时指向某变量，当变量生命周期结束后必须重新赋值为nil，否则后续解引用会panic。
4. 与空接口nil的语义不同，nil只是一个空值，空接口nil可以代表任意零值。

### new 和 make

在Go语言中，``*new``和``make``都是用于内存分配的关键字，但有以下区别：

``*new``：

1. ``*new(T)``分配一个T类型的内存，并返回其地址，是一个类型为``*T``的指针。
2. ``*new(T)``返回的指针对应的值为``T``类型的零值。
3. ``*new(T)``分配的内存由Go的垃圾回收器管理。

`make`：

1. `make(T)`分配并初始化一个T类型的内存，T必须是map，slice或chan类型。
2. `make(T)`返回的类型就是T。
3. `make(T)`分配的内存由Go的垃圾回收器管理。

例如：

```go
p ：= new(int)   // p为*int类型，指向默认值0的变量
v ：= *p          // v = 0

m ：= make(map[int]string) 
s ：= make([]int， 5)       // s = [0， 0， 0， 0， 0]
c ：= make(chan int)
```
所以，区别在于：
**``*new``：**

1. **用于分配任意类型的内存，返回指针。**
2. **指针指向的变量默认初始化为类型的零值。**

**`make`：**

1. **只用于分配map，slice，channel等内建类型的内存。**
2. **返回的并不是指针，而是初始化后的类型本身。**
3. **返回的类型已完成初始化，不是零值。**

需要注意：

1. ``*new``返回指针，需要进行解引用``*``来访问目标变量。而``make``直接返回初始化后的值。
2. ``*new``分配的内存在首次使用前值是未定义的，make分配的内存在返回前即完成初始化。
3. ``*new``和``make``都由垃圾回收器管理内存，不需要显示释放。但也需要注意生命周期，避免延长导致的内存泄漏。

## Map

### Map实现原理

## 结构体

## 流程控制

## 函数

## 方法

## 面向对象

## 网络编程

## 常用标准库
