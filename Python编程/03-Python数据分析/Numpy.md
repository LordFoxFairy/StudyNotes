## Numpy

### 什么是Numpy？

NumPy是Python中科学计算的基础软件包。 它是一个提供多了维数组对象，多种派生对象（如：掩码数组、矩阵）以及用于快速操作数组的函数及API， 它包括数学、逻辑、数组形状变换、排序、选择、I/O 、离散傅立叶变换、基本线性代数、基本统计运算、随机模拟等等。

NumPy中的核心是ndarray对象。ndarray对象是具有相同类型和大小（通常是固定大小）项目的多维容器。可以对其进行索引、切片、形状变换等操作。

### 关于axis

根据官方的说法，1表示横轴，方向从左到右；0表示纵轴，方向从上到下，即axis=1为横向，axis=0为纵向。

> 有时候理解为行和列会很容易使用的，但实际不是表示行列

### 数组

* 数组内元素的类型需要相同
* 创建数组大小固定

#### 创建数组

In [1]：

```python
import numpy as np

a = np.array( # 创建一个1x3的一维数组
    [1,2,3]
)
a
```

Out[1]：

```txt
array([1, 2, 3])
```

In [2]：

```python
type(a) # 数据类型
```

Out[2]：

```txt
numpy.ndarray # 数组类型为ndarray
```

#### ndarray对象的属性

##### ndarray.shape

数组的形状。返回一个元组表示各个维度中数组的大小。

In [3]：

```
a.shape # 每行元素的个数
```

Out[3]：

```
(3,)
```

In [11]：

```
b = np.array( # 创建一个2x3的二维数组
    [
        [1,2,3],
        [4,5,6]
    ]
)
b
```

Out[11]：

```
array([[1, 2, 3],
       [4, 5, 6]])
```

In [13]：

```
b.shape # 数组形状即几行几列
```

Out[13]：

```
(2, 3)
```

##### ndarray.ndim

数组的轴（维度）的个数即几行。维度的数量被称为rank。

In [4]：

```
a.ndim # 1行，维度即几行
```

Out[4]：

```
1
```

#####  ndarray.size

数组中元素的总数。等于shape各个元素的乘积。

In [5]：

```
a.size # 数组中元素的总个数
```

Out[5]：

```
3
```

##### ndarray.dtype

一个描述数组中元素类型的**对象**。

In [6]：

```
a.dtype # 数组中元素的类型
```

Out[6]：

```
dtype('int32')
```

##### ndarray.itemsize

数组中每个元素的字节大小。

In [7]：

```
a.itemsize # 数组中每个元素的字节大小
```

Out[7]：

```
4
```

##### ndarray.real

数组的实部

In [8]：

```
g = np.array(
    [1+2j,2+3j]
)
g.dtype
```

Out[8]：

```
dtype('complex128')
```

In [9]：

```
g.real
```

Out[9]：

```
array([1., 2.])
```

##### ndarray.imag

数组的虚部

In [10]：

```
g.imag
```

Out[10]：

```
array([2., 3.])
```

#### ndarray的创建方法

##### nd.array()

In [1]：

```python
import numpy as np

np.array( # 创建一个1x3的一维数组
    [1,2,3]
```

Out[1]：

```txt
array([1, 2, 3])
```

##### np.asarray()

array()和asarray()都可以将结构数据转化为ndarray，但是主要区别就是当数据源是ndarray时，array仍然会copy出一个副本，占用新的内存，但asarray不会。

In [14]：

```
np.asarray([1,2])
```

Out[14]：

```
array([1, 2])
```

In [15]：

```
np.asarray(np.array([1,2,3]))
```

Out[15]：

```
array([1, 2, 3])
```

##### np.zeros(shape, dtype=float)

创建一个全为0的数组（ndarray对象）

* shape：形状，即创建几行几列的数组
* dtype：数组内值得数据类型

In [16]：

```
np.zeros(5,dtype=int)
```

Out[16]：

```
array([0, 0, 0, 0, 0])
```

In [17]：

```
np.zeros((5,))
```

Out[17]：

```
array([0., 0., 0., 0., 0.])
```

In [18]：

```
np.zeros((5,5))
```

Out[18]：

```
array([[0., 0., 0., 0., 0.],
       [0., 0., 0., 0., 0.],
       [0., 0., 0., 0., 0.],
       [0., 0., 0., 0., 0.],
       [0., 0., 0., 0., 0.]])
```

##### np.zeros_like()

传入一个数组作为参数，根据该数组的形状和dtype创建一个全0的ndaray对象

In [19]：

```
np.zeros_like(
    [
        [1.2,1.3,2],
        [1.2,1.3,2]
    ]
)
```

Out[19]：

```
array([[0., 0., 0.],
       [0., 0., 0.]])
```

##### np.empty((shape, dtype=float)

类似于np.zeros(),但只分配内存但是不填充任何值

* shape：形状，即创建几行几列的数组
* dtype：数组内值得数据类型

In [20]：

```
np.empty(5)
```

Out[20]：

```
array([0., 0., 0., 0., 0.])
```

##### np.empty_like()

同上

略

##### np.full(shape, fill_value, dtype=None,)

根据指定形状传建一个数组（ndarray对象），并用fill_value的值进行填充

* shape：指定ndarray数组的大小、
* fill_vallue：填充值，即数组内值全为fill_valule

In [21]：

```
np.full((3,2),fill_value=5)
```

Out[21]：

```
array([[5, 5],
       [5, 5],
       [5, 5]])
```

##### np.full_like()

同上

略

##### np.eye()

传入一个整数N，创建一个N * N的单位矩阵

In [22]：

```
np.eye(5) # 创建一个5x5的单位矩阵(identity matrix)
```

Out[22]：

```
array([[1., 0., 0., 0., 0.],
       [0., 1., 0., 0., 0.],
       [0., 0., 1., 0., 0.],
       [0., 0., 0., 1., 0.],
       [0., 0., 0., 0., 1.]])
```

##### np.identity()

传入一个整数N，创建一个N * N的单位矩阵，类似于np.eye()

In [23]：

```
np.identity(5)
```

Out[23]：

```
array([[1., 0., 0., 0., 0.],
       [0., 1., 0., 0., 0.],
       [0., 0., 1., 0., 0.],
       [0., 0., 0., 1., 0.],
       [0., 0., 0., 0., 1.]])
```

##### np.random

随机抽样创建数组

* rand：产生指定形状的均匀分布的样本值
* randn：返回一个或一组样本，具有标准正态分布
* randint：从给定的上下限范围内选取随机整数
* binomial：产生二项分布的样本值
* normal：产生正态（高斯）分布的样本值
* beta：生Beta分布的样本值
* chisquare：产生卡方分布的样本值
* gamma：产生Gamma分布的样本值
* uniform：产生在指定范围中均匀分布的样本值
* shuffle：一个序列就地随机排列

In [24]：

```
np.random.rand(3,2)
```

Out[24]：

```
array([[0.87739699, 0.62405667],
       [0.05264142, 0.21515255],
       [0.34419254, 0.79204327]])
```

In [25]：

```
np.random.randn(3,2)
```

Out[25]：

```
array([[-0.71596008, -0.73378479],
       [-0.99908948,  0.70328556],
       [-0.55219447,  0.02029755]])
```

##### np.arange(start,stop,step,dtype)

创建一位数组，从start~stop（不包括stop）范围内选取值，步长为step，默认为1

In [26]：

```
np.arange(5)
```

Out[26]：

```
array([0, 1, 2, 3, 4])
```

In [27]：

```
np.arange(5,5)
```

Out[27]：

```
array([], dtype=int32)
```

In [28]：

```
np.arange(1,5,2)
```

Out[28]：

```
array([1, 3])
```

##### np.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None, axis=0)

返回一个在指定范围内(start~stop，但不包括stop)指定大小num（默认为50）的一位数组

In [29]：

```
np.linspace(1,5)
```

Out[29]：

```
array([1.        , 1.08163265, 1.16326531, 1.24489796, 1.32653061,
       1.40816327, 1.48979592, 1.57142857, 1.65306122, 1.73469388,
       1.81632653, 1.89795918, 1.97959184, 2.06122449, 2.14285714,
       2.2244898 , 2.30612245, 2.3877551 , 2.46938776, 2.55102041,
       2.63265306, 2.71428571, 2.79591837, 2.87755102, 2.95918367,
       3.04081633, 3.12244898, 3.20408163, 3.28571429, 3.36734694,
       3.44897959, 3.53061224, 3.6122449 , 3.69387755, 3.7755102 ,
       3.85714286, 3.93877551, 4.02040816, 4.10204082, 4.18367347,
       4.26530612, 4.34693878, 4.42857143, 4.51020408, 4.59183673,
       4.67346939, 4.75510204, 4.83673469, 4.91836735, 5.        ])
```

In [30]：

```
np.linspace(1,5,2)
```

Out[30]：

```
array([1., 5.])
```

##### np.fromfunction(function, shape, **kwargs)

通过对每个执行函数来构造一个数组

* function：执行函数
* shape：数组大小

In [31]:

```
def mime(a,b):
    return b
np.fromfunction(mime,(3,3))
```

Out[31]:

```
array([[0., 1., 2.],
       [0., 1., 2.],
       [0., 1., 2.]])
```

In [32]:

```
def mime(a,b):
    return a
np.fromfunction(mime,(3,3))
```

Out[32]:

```
array([[0., 0., 0.],
       [1., 1., 1.],
       [2., 2., 2.]])
```

In [33]:

```
def add(a,b):
    return a+b
np.fromfunction(add,(3,3))
```

Out[33]:

```
array([[0., 1., 2.],
       [1., 2., 3.],
       [2., 3., 4.]])
```

In [34]:

```
def dot(a,b):
    return a*b
np.fromfunction(dot,(3,3))
```

Out[34]:

```
array([[0., 0., 0.],
       [0., 1., 2.],
       [0., 2., 4.]])
```

### 数据类型

- 所有的数据类型如下表所示：

|                          数据类型 |     类型代码 |                                        说明 |
| --------------------------------: | -----------: | ------------------------------------------: |
|                       int8、uint8 |       i1、u1 |          有符号和无符号的8位（1个字节）整形 |
|                     int16、uint16 |       i2、u2 |         有符号和无符号的16位（2个字节）整形 |
|                     int32、uint32 |       i4、u4 |         有符号和无符号的32位（4个字节）整形 |
|                     int64、uint64 |       i8、u8 |         有符号和无符号的64位（8个字节）整形 |
|                           float16 |           f2 |                                半精度浮点数 |
|                           float32 |        f4或f |                          标准的单精度浮点数 |
|                           float64 |        f8或d |                          标准的双精度浮点数 |
|                          float128 |       f16或g |                              扩展精度浮点数 |
|                              bool |            ? |              存储布尔类型（存储为一个字节） |
|                            object |            O |                              Python对象类型 |
|                           string_ |            S |     固定长度的字符串类型（每个字符1个字节） |
|                          unicode_ |            U |   固定长度的unicode类型（字节数由平台决定） |
| complex64、complex128、complex256 | c8、c16、c32 | 分别用两个32位、64位或128位浮点数表示的复数 |

注意：`int_`为`int32`的简写，`float_`为`float64`的简写，`complex_`为`complex128`的简写

In [1]:

```
a = np.array([1,2,3])
a.dtype
```

Out[1]:

```
dtype('int32')
```

### 数组运算

In [1]:

```
import numpy as np
```

In [2]:

```
a = np.array([
    [1,2,3],
    [4,5,6],
])
a
```

Out[2]:

```
array([[1, 2, 3],
       [4, 5, 6]])
```

#### 数组与标量的算术运算

In [3]:

```
a * 2
```

Out[3]:

```
array([[ 2,  4,  6],
       [ 8, 10, 12]])
```

##### 加法

In [5]:

```
a+a
```

Out[5]:

```
array([[ 2,  4,  6],
       [ 8, 10, 12]])
```

##### 减法

In [6]:

```
a-a # np.subtract(a,a)
```

Out[6]:

```
array([[0, 0, 0],
       [0, 0, 0]])
```

##### 除法

In [7]:

```
a/a # np.divide(a,a)
```

Out[7]:

```
array([[1., 1., 1.],
       [1., 1., 1.]])
```

In [8]:

##### 星乘（*）与点乘（.）

In [8]:

```
a = np.array([
    [1,2,3],
    [1,2,3]
])
b = np.array([
    [1,1,1],
    [1,1,1]
])
```

In [9]:

```
a*b # np.multiply(a,b)
```

Out[9]:

```
array([[1, 2, 3],
       [1, 2, 3]])
```

In [10]:

```
np.dot(a,b)
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-10-3339b236d1c5> in <module>
----> 1 np.dot(a,b)

<__array_function__ internals> in dot(*args, **kwargs)

ValueError: shapes (2,3) and (2,3) not aligned: 3 (dim 1) != 2 (dim 0)
```

In [11]:

```
a = np.array([
    [1,2,],
    [1,2,]
])
b = np.array([
    [1,1,],
    [1,1,]
])
```

In [12]:

```
np.dot(a,b)
```

Out[12]:

```
array([[3, 3],
       [3, 3]])
```

In [13]:

```
a.dot(b)
```

Out[13]:

```
array([[3, 3],
       [3, 3]])
```

### 拷贝

- 完全不拷贝：两个变量公用一个数组，引用的地址都是同一个

In [14]:

```
a = np.arange(10)
b = a
```

Out[14]:

```
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
```

In [15]:

```
a
```

Out[15]:

```
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
```

In [16]:

```
b
```

Out[16]:

```
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
```

In [17]:

```
b[0] = 100
b
```

Out[17]:

```
array([100,   1,   2,   3,   4,   5,   6,   7,   8,   9])
```

In [18]:

```
a
```

Out[18]:

```
array([100,   1,   2,   3,   4,   5,   6,   7,   8,   9])
```

- 浅拷贝：与上有区别，一个数组值会变化会反映在另一个数组上，但是形状不变化

In [21]:

```
a = np.arange(10)
b = a.view()
```

In [22]:

```
a
```

Out[22]:

```
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
```

In [23]:

```
b
```

Out[23]:

```
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
```

In [24]:

```
b[0] = 500
```

In [25]:

```
a
```

Out[25]:

```
array([500,   1,   2,   3,   4,   5,   6,   7,   8,   9])
```

In [26]:

```
b
```

Out[26]:

```
array([500,   1,   2,   3,   4,   5,   6,   7,   8,   9])
```

In [30]:

```
b.shape = (10,1)
b
```

Out[30]:

```
array([[500],
       [  1],
       [  2],
       [  3],
       [  4],
       [  5],
       [  6],
       [  7],
       [  8],
       [  9]])
```

In [31]:

```
a
```

Out[31]:

```
array([500,   1,   2,   3,   4,   5,   6,   7,   8,   9])
```

- 深拷贝：创建原数组的副本，副本的任何变化都不会反映在原数组上

In [32]:

```
a = np.arange(10)
b = a.copy()
```

In [33]:

```
b[0] = 500
```

In [34]:

```
a
```

Out[34]:

```
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
```

In [35]:

```
b
```

Out[35]:

```
array([500,   1,   2,   3,   4,   5,   6,   7,   8,   9])
```

### 索引与切片

In [36]:

```
a = np.arange(36).reshape(6,6)
a
```

Out[36]:

```
array([[ 0,  1,  2,  3,  4,  5],
       [ 6,  7,  8,  9, 10, 11],
       [12, 13, 14, 15, 16, 17],
       [18, 19, 20, 21, 22, 23],
       [24, 25, 26, 27, 28, 29],
       [30, 31, 32, 33, 34, 35]])
```

* 取第2,3,4行的数据，注意索引从0开始

In [37]:

```
a[[1,2,3]]
```

Out[37]:

```
array([[ 6,  7,  8,  9, 10, 11],
       [12, 13, 14, 15, 16, 17],
       [18, 19, 20, 21, 22, 23]])
```

* 取（2,4），（3,5），（4,6）的值

In [39]:

```
a[[1,2,3],[3,4,5]]
```

Out[39]:

```
array([ 9, 16, 23])
```

* 取第2,3,4行后，再取第4,5,6列的值

In [42]:

```
a[[1,2,3]][:,[3,4,5]]
```

Out[42]:

```
array([[ 9, 10, 11],
       [15, 16, 17],
       [21, 22, 23]])
```

### 统计方法 ☆☆☆

In [1]:

```
import numpy as np
```

In [2]:

```
a = np.array([
    [np.NaN,2,3,4],
    [2,np.NaN,4,5],
    [3,4,np.NaN,6]
])
```

In [3]:

```
a
```

Out[3]:

```
array([[nan,  2.,  3.,  4.],
       [ 2., nan,  4.,  5.],
       [ 3.,  4., nan,  6.]])
```

#### amin(a[, axis, out, keepdims]

返回数组的最小值或沿轴的最小值

见下

##### amax(a[, axis, out, keepdims])

返回数组的最大值或沿轴的最大值

In [4]:

```
np.amax(a,axis=0) # axis=0表示列
```

Out[4]:

```
array([nan, nan, nan,  6.])
```

In [5]:

```
np.amax(a,axis=1) # axis=1表示行
```

Out[5]:

```
array([nan, nan, nan])
```

In [6]:

```
np.amax(a) # 整个数组
```

Out[6]:

```
nan
```

#### nanmin(a[, axis, out, keepdims])

返回数组的最小值或沿轴的最小值，忽略任何NAN

见下

##### nanmax(a[, axis, out, keepdims])

返回数组的最大值或沿轴方向的最大值，忽略任何NAN

In [7]:

```
np.nanmin(a)
```

Out[7]:

```
2.0
```

In [8]:

```
np.nanmax(a)
```

Out[8]:

```
6.0
```

#### median(a[, axis, out, overwrite_input, keepdims])

沿指定轴计算中值

略

####　nanmedian(a[, axis, out, overwrite_input, …])

在忽略NAS的情况下，沿指定的轴计算中值

In [9]:

```
np.nanmedian(a)
```

Out[9]:

```
4.0
```

#### average(a[, axis, weights, returned])

计算沿指定轴的加权平均

见下

#### mean(a[, axis, dtype, out, keepdims])

沿指定的轴计算算术平均值

见下

#### nanmean(a[, axis, dtype, out, keepdims])

计算沿指定轴的算术平均值，忽略NAN

In [11]:

```
b = a.copy()
b
```

Out[11]:

```
array([[nan,  2.,  3.,  4.],
       [ 2., nan,  4.,  5.],
       [ 3.,  4., nan,  6.]])
```

In [12]:

```
b[np.isnan(b)]=np.nanmean(b) # 筛选出所有nan值然后用均值进行替换
b
```

Out[12]:

```
array([[3.66666667, 2.        , 3.        , 4.        ],
       [2.        , 3.66666667, 4.        , 5.        ],
       [3.        , 4.        , 3.66666667, 6.        ]])
```

#### std(a[, axis, dtype, out, ddof, keepdims])

计算沿指定轴的标准偏差即标准差

见下

#### nanstd(a[, axis, dtype, out, ddof, keepdims])

计算指定轴上的标准偏差，而忽略NAN

In [14]:

```
np.nanstd(a)
```

Out[14]:

```
1.247219128924647
```

#### var(a[, axis, dtype, out, ddof, keepdims])

计算沿指定轴的方差

见下

#### nanvar(a[, axis, dtype, out, ddof, keepdims])

计算指定轴上的方差，同时忽略NAN

In [15]:

```
np.nanvar(a)
```

Out[15]:

```
1.5555555555555556
```

### 形状变换

#### 重塑

- ndarray.reshape(shape, order='C')

- ndarray.resize()

  注意：reshape 函数返回修改后的新对象，而 ndarray.resize 方法修改数组本身

- 重塑的各个维度上整数的乘积必须等于arr.size

- 如果想让自动计算某个轴上的大小，可以传入-1

#### 扁平化处理

In [1]:

```
import numpy as np

a = np.array([[1,2,5],[2,3,5],[3,4,5],[2,3,6]])
a
```

Out[1]:

```
array([[1, 2, 5],
       [2, 3, 5],
       [3, 4, 5],
       [2, 3, 6]])
```

In [2]:

```
a.flatten()
```

Out[2]:

```
array([1, 2, 5, 2, 3, 5, 3, 4, 5, 2, 3, 6])
```

In [3]:

```
b = a.ravel() # flatten()与ravel()都是讲数组变成一维数组，但是flatten会重新创建一个新的对			  # 象，ravel()只是返回一个视图，如果修改了其中的值，原数组也会被修改
```

In [4]:

```
b[0] = 100
a
```

Out[4]:

```
array([[100,   2,   5],
       [  2,   3,   5],
       [  3,   4,   5],
       [  2,   3,   6]])
```

#### 数组合并

##### concatenate

沿着一条轴连接一组（多个）数组。除了与axis对应的轴之外，其它轴必须有相同的形状。

In [1]:

```
import numpy as np

a = np.array([
    [1,2,3],
    [4,5,6]
])

b = np.array([
    [5,6,7],
    [8,9,10]
])
```

In [2]:

```
np.concatenate((a,b),axis=0) # 垂直拼接
```

Out[2]:

```
array([[ 1,  2,  3],
       [ 4,  5,  6],
       [ 5,  6,  7],
       [ 8,  9, 10]])
```

In [3]:

```
np.concatenate((a,b),axis=1) # 将两个二维数组分别转化为一维数组后，在垂直拼接
```

Out[3]:

```
array([[ 1,  2,  3,  5,  6,  7],
       [ 4,  5,  6,  8,  9, 10]])
```

##### vstack&row_stack

以追加行的方式对数组进行连接（沿轴0）即垂直方向

In [4]:

```
np.vstack((a,b))
```

Out[4]:

```
array([[ 1,  2,  3],
       [ 4,  5,  6],
       [ 5,  6,  7],
       [ 8,  9, 10]])
```

In [5]:

```
np.row_stack((a,b))
```

Out[5]:

```
array([[ 1,  2,  3],
       [ 4,  5,  6],
       [ 5,  6,  7],
       [ 8,  9, 10]])
```

##### hstack

以追加列的方式对数组进行连接（沿轴1）即水平方向

In [6]:

```
np.hstack((a,b))
```

Out[6]:

```
array([[ 1,  2,  3,  5,  6,  7],
       [ 4,  5,  6,  8,  9, 10]])
```

##### column_stack

类似于hstack，但是会先将一维数组转换为二维列向量

In [7]:

```
np.column_stack((a,b))
```

Out[7]:

```
array([[ 1,  2,  3,  5,  6,  7],
       [ 4,  5,  6,  8,  9, 10]])
```

##### dstack

以面向“深度”的方式对数组进行叠加

In [8]:

```
np.dstack((a,b))
```

Out[8]:

```
array([[[ 1,  5],
        [ 2,  6],
        [ 3,  7]],

       [[ 4,  8],
        [ 5,  9],
        [ 6, 10]]])
```

#### 数组拆分

##### split

沿指定轴在指定的位置拆分数组

In [9]:

```
c = np.arange(36).reshape(6,-1)
c
```

Out[9]:

```
array([[ 0,  1,  2,  3,  4,  5],
       [ 6,  7,  8,  9, 10, 11],
       [12, 13, 14, 15, 16, 17],
       [18, 19, 20, 21, 22, 23],
       [24, 25, 26, 27, 28, 29],
       [30, 31, 32, 33, 34, 35]])
```

In [10]:

```
np.split(c,2,axis=0) # 从第二行开始进行拆分，axis=0代表行方向
```

Out[10]:

```
[array([[ 0,  1,  2,  3,  4,  5],
        [ 6,  7,  8,  9, 10, 11],
        [12, 13, 14, 15, 16, 17]]),
 array([[18, 19, 20, 21, 22, 23],
        [24, 25, 26, 27, 28, 29],
        [30, 31, 32, 33, 34, 35]])]
```

In [11]:

```
np.split(c,2,axis=1) # 从第二列开始进行拆分，axis=1代表列方向
```

Out[11]:

```
[array([[ 0,  1,  2],
        [ 6,  7,  8],
        [12, 13, 14],
        [18, 19, 20],
        [24, 25, 26],
        [30, 31, 32]]),
 array([[ 3,  4,  5],
        [ 9, 10, 11],
        [15, 16, 17],
        [21, 22, 23],
        [27, 28, 29],
        [33, 34, 35]])]
```

In [12]:

```
np.split(c,[2,3,4],axis=0) # 第二项参数可以为列表，分别从第二行，第三行，第四行，进行拆分
```

Out[12]:

```
[array([[ 0,  1,  2,  3,  4,  5],
        [ 6,  7,  8,  9, 10, 11]]),
 array([[12, 13, 14, 15, 16, 17]]),
 array([[18, 19, 20, 21, 22, 23]]),
 array([[24, 25, 26, 27, 28, 29],
        [30, 31, 32, 33, 34, 35]])]
```

##### hsplit、vsplit、dsplit

split的便捷化函数，分别沿轴0、轴1、轴2进行拆分

#### 重复数组

##### repeat

对数组中的元素进行复制

In [13]:

```
d = np.arange(5)
d
```

Out[13]:

```
array([0, 1, 2, 3, 4])
```

In [14]:

```
np.repeat(d,3) # 所有元素都重复3次
```

Out[14]:

```
array([0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4])
```

In [15]:

```
np.repeat(d,[1,1,2,5,6]) # 指定每个元素进行重复的次数，列表中的值代表数组中的该位置的元素进行重复的次数
```

Out[15]:

```
array([0, 1, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4])
```

> 注意在多维数组中，不指定axis轴方向，会扁平化

##### tile



对整个数组进行复制

In [16]:

```
np.tile(d,2) # 水平复制
```

Out[16]:

```
array([0, 1, 2, 3, 4, 0, 1, 2, 3, 4])
```

In [17]:

```
f = np.arange(9).reshape(3,-10)
f
```

Out[17]:

```
array([[0, 1, 2],
       [3, 4, 5],
       [6, 7, 8]])
```

In [18]:

```
np.tile(f,2) # 水平复制
```

Out[18]:

```
array([[0, 1, 2, 0, 1, 2],
       [3, 4, 5, 3, 4, 5],
       [6, 7, 8, 6, 7, 8]])
```

In [19]:

```
np.tile(f,(1,2))# 将f数组，变成一个1x2的f构成
```

Out[19]:

```
array([[0, 1, 2, 0, 1, 2],
       [3, 4, 5, 3, 4, 5],
       [6, 7, 8, 6, 7, 8]])
```

In [20]:

```
np.tile(f,(2,3)) # 将f数组，变成一个2x3的f构成
```

Out[20]:

```
array([[0, 1, 2, 0, 1, 2, 0, 1, 2],
       [3, 4, 5, 3, 4, 5, 3, 4, 5],
       [6, 7, 8, 6, 7, 8, 6, 7, 8],
       [0, 1, 2, 0, 1, 2, 0, 1, 2],
       [3, 4, 5, 3, 4, 5, 3, 4, 5],
       [6, 7, 8, 6, 7, 8, 6, 7, 8]])
```

#### 转置

ndarray数组对象.T即可得到ndarray对象的转置

In [21]:

```
h = np.arange(25).reshape(5,-1) # 等价于reshape(5,5)
h
```

Out[21]:

```
array([[ 0,  1,  2,  3,  4],
       [ 5,  6,  7,  8,  9],
       [10, 11, 12, 13, 14],
       [15, 16, 17, 18, 19],
       [20, 21, 22, 23, 24]])
```

In [23]:

```
h.T # 转置
```

Out[23]:

```
array([[ 0,  5, 10, 15, 20],
       [ 1,  6, 11, 16, 21],
       [ 2,  7, 12, 17, 22],
       [ 3,  8, 13, 18, 23],
       [ 4,  9, 14, 19, 24]])
```

In [24]:

```
h.transpose() # 转置
```

Out[24]:

```
array([[ 0,  5, 10, 15, 20],
       [ 1,  6, 11, 16, 21],
       [ 2,  7, 12, 17, 22],
       [ 3,  8, 13, 18, 23],
       [ 4,  9, 14, 19, 24]])
```

### 通用函数☆☆☆

一元ufunc

|                                              函数 | 说明                                                         |
| ------------------------------------------------: | :----------------------------------------------------------- |
|                                         abs、fabs | 计算整数、浮点数或复数的绝对值。对于非复数值，可以使用更快的fabs |
|                                              sqrt | 计算各元素的平方根。相当于arr ** 0.5                         |
|                                            square | 计算各元素的平方。相当于arr ** 2                             |
|                                               exp | 计算各元素的指数。相当于e的x次方                             |
|                           log、log10、log2、log1p | 分别对应自然对数（底数为e）、底数为10的log、底数为2的log、log(1 + p) |
|                                              sign | 计算各元素的正负号：1（正数）、0（零）、-1（负数）           |
|                                              ceil | 计算各元素的ceiling值，即大于等于该值的最小整数              |
|                                             floor | 计算各元素的floor值。即小于等于该值的最大整数                |
|                                              rint | 将各元素值四舍五入到最接近的整数，保留dtype                  |
|                                              modf | 将数组的小数和整数部分以两个独立数组的形式返回               |
|                                                   |                                                              |
|                                             isnan | 返回一个表示“哪些值是NaN”的布尔型数组                        |
|                                                   |                                                              |
|                                   isfinite、isinf | 分别返回一个表示“哪些元素是有穷的（非inf，非NaN）”或“哪些元素是无穷的”的布尔型数组 |
|                                                   |                                                              |
|                   cos、cosh、sin、sinh、tan、tanh | 普通型和双曲型三角函数                                       |
| arccos、arccosh、arcsin、arcsinh、arctan、arctanh | 反三角函数                                                   |
|                                       logical_not | 计算个元素的not x的真值。相当于-arr                          |

二元ufunc

|                                                         函数 |                                                         说明 |
| -----------------------------------------------------------: | -----------------------------------------------------------: |
|                                                          add |                                       将数组中对应的元素相加 |
|                                                     subtract |                         从第一个数组中减去第二个数组中的元素 |
|                                                     multiply |                                               将数组元素相乘 |
|                                         divide、floor_divide |                               除法或向下取整除法（丢弃余数） |
|                                                        power | 对第一个数组中的元素A，根据第二个数组中的相应元素B，计算A的B次方 |
|                                                maximum、fmax |                            元素级的最大值计算。fmax将忽略NaN |
|                                                minimum、fmin |                            元素级的最小值计算。fmin将忽略NaN |
|                                                          mod |                             元素级别的求模计算（除法的余数） |
|                                                     copysign |               将第二个数组中的值得符号复制给第一个数组中的值 |
| greater、greater_equal、less、less_equal、equal、not_equal、 | 执行元素级的比较运算，最终产生布尔数组。相当于中缀运算符号>、>=、<、<=、==、!= |
|                                                              |                                                              |
|                         logical_and、logical_or、logical_xor |          执行元素级的真值逻辑运算。相当于中缀运算符&、\| 、^ |
|                                                              |                                                              |

In [24]:

```
a = np.random.randn(5)
b = np.random.randn(5)
```

In [25]:

```
a
```

Out[25]:

```
array([-0.09068035, -0.187416  ,  0.94935988,  2.43188324, -1.71809499])
```

In [26]:

```
b
```

Out[26]:

```
array([-0.55215555,  0.49648021,  1.45710124, -1.47626841, -1.38574365])
```

In [27]:

```
np.abs(a)
```

Out[27]:

```
array([0.09068035, 0.187416  , 0.94935988, 2.43188324, 1.71809499])
```

In [28]:

```
np.rint(a)
```

Out[28]:

```
array([-0., -0.,  1.,  2., -2.])
```

In [29]:

```
np.subtract(a,b)
```

Out[29]:

```
array([ 0.4614752 , -0.68389622, -0.50774136,  3.90815164, -0.33235134])
```

### 搜索和计数☆☆☆

#### 搜索

##### argmax(a[, axis, out])

返回沿轴的最大值的索引即最大值所在位置的下标

In [1]:

```
import numpy as np

a = np.arange(36).reshape(6,-1)
a
```

Out[1]:

```
array([[ 0,  1,  2,  3,  4,  5],
       [ 6,  7,  8,  9, 10, 11],
       [12, 13, 14, 15, 16, 17],
       [18, 19, 20, 21, 22, 23],
       [24, 25, 26, 27, 28, 29],
       [30, 31, 32, 33, 34, 35]])
```

In [2]:

```
np.argmax(a) # 整个数组其中最大值的下标，以flatten扁平化后的下标进行返回
```

Out[2]:

```
35
```

In [3]:

```
np.argmax(a,axis=0) # 每行最大值的下标
```

Out[3]:

```
array([5, 5, 5, 5, 5, 5], dtype=int64)
```

In [4]:

```
np.argmax(a,axis=1 # 每列最大值的下标
```

Out[4]:

```
array([5, 5, 5, 5, 5, 5], dtype=int64)
```

##### nanargmax(a[, axis])

返回指定轴上最大值的索引，忽略NAN

略

##### argmin(a[, axis, out])

返回沿轴的最小值的索引即最小值所在位置的下标

In [5]:

```
np.argmin(a)
```

Out[5]:

```
0
```

#####　nanargmin(a[, axis])

返回指定轴上的最小值的索引，忽略NAN



#####　argwhere(a)

返回按元素分组的非零数组元素的索引。

In [8]:

```
np.argwhere(a>28) # 帅选出条件符合的值得下标即(i,j)
```

Out[8]:

```
array([[4, 5],
       [5, 0],
       [5, 1],
       [5, 2],
       [5, 3],
       [5, 4],
       [5, 5]], dtype=int64)
```

#####　nonzero(a)

返回非零元素的索引，以两个数组的形式进行返回，第一个数组为行下标，第二个数组为列下标

In [9]:

```
np.nonzero(a)
```

Out[9]:

```
(array([0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3,
        3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5], dtype=int64),
 array([1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4,
        5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5], dtype=int64))
```

#####　flatnonzero(a)

返回a的展平版本中非零的索引

In [10]:

```
np.flatnonzero(a) # 将数组扁平化后也就是变成一维数组后，返回一维                   # 数组的下标
```

Out[10]:

```
array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17,
       18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34,
       35], dtype=int64)
```

#####　where(condition, [x, y])☆

返回元素，可以是x或y，具体取决于条件

In [11]:

```
np.where(a>30) # 与argwehe方法类似，只是where是分别用两个数组，                # 进行存储符合条件的值得行下标以及列下标
```

Out[11]:

```
(array([5, 5, 5, 5, 5], dtype=int64), array([1, 2, 3, 4, 5], dtype=int64))
```

In [12]:

```
b = np.array([
    1,2,3,4
])
c = np.array([
    'a','b','c','d'
])
condtion = np.array([
    True,False,True,False
])
np.where(condtion,b,c) # 根据condition条件将c中符合的数据替换掉b中相应位置的数据
```

Out[12]:

```
array(['1', 'b', '3', 'd'], dtype='<U11')
```

In [13]:

```
np.where(a>10,0,a) # 将大于10的值全部替换为0
```

Out[13]:

```
array([[ 0,  1,  2,  3,  4,  5],
       [ 6,  7,  8,  9, 10,  0],
       [ 0,  0,  0,  0,  0,  0],
       [ 0,  0,  0,  0,  0,  0],
       [ 0,  0,  0,  0,  0,  0],
       [ 0,  0,  0,  0,  0,  0]])
```

#####　searchsorted(a, v[, side, sorter])

查找应插入元素以维护顺序的索引

In [14]:

```
d = np.array([8,15,3,12,5])
f = np.array([3,5,8,12,15])
```

In [15]:

```
np.searchsorted(f,7) # 默认先往左插，插入7后，值7的下标位置
```

Out[15]:

```
2
```

In [16]:

```
np.searchsorted(f,7,side='right') # 往右插，插入7后，值7的下标位置
```

Out[16]:

```
2
```

In [17]:

```
np.searchsorted(f,8)
```

Out[17]:

```
2
```

In [18]:

```
np.searchsorted(f,8,side='right')
```

Out[18]:

```
3
```

#####　extract(condition, arr)

返回满足某些条件的数组元素



####　计数

#####　count_nonzero(a[, axis])

计算数组a中的非零值的数量

In [20]:

```
np.count_nonzero([[1,2,3,4,5,0],[0,0,0,0,0,1]]) # 统计数组中非0数量
```

Out[20]:

```
6
```

In [21]:

```
np.count_nonzero([[1,2,3,4,5,0],[0,0,0,0,0,1]],axis=0) # 统计沿垂直方向的非0数量
```

Out[21]:

```
array([1, 1, 1, 1, 1, 1], dtype=int64)
```

In [22]:

```
np.count_nonzero([[1,2,3,4,5,0],[0,0,0,0,0,1]],axis=1) # 统计沿水平方向的非0数量
```

Out[22]:

```
array([5, 1], dtype=int64)
```

### 线性代数

##### diag(v, k=0)

以一维数组的形式返回方阵的对角线（或非对角线）元素，或将一数组转换为方阵（非对角线元素为0）

In [24]:

```
np.diag(g) # 以一维数组形式返回对角元素
```

Out[24]:

```
array([ 0,  6, 12, 18, 24])
```

In [25]:

```
np.diag(g,1)# 返回从下标i=1开始打得对角元素
```

Out[25]:

```
array([ 1,  7, 13, 19])
```

In [26]:

```
np.diag(np.array([ # 若为一维数组，则返回一个二维数组，对角元素为一维数组相对应的值，其余为0
    1,2,3
]))
```

Out[26]:

```
array([[1, 0, 0],
       [0, 2, 0],
       [0, 0, 3]])
```

#####　dot(a, b[, out])

两个数组的点积

In [27]:

```
a = np.array([
    [1,2,],[4,5]
])
b = np.array([
    [5,2,],[6,9]
])
np.dot(a,b) # 返回矩阵乘积
```

Out[27]:

```
array([[17, 20],
       [50, 53]])
```

#####　trace(a[, offset, axis1, axis2, dtype, out])

计算对角线元素的和

In [28]:

```
np.trace(a) # 对角元素和
```

Out[28]:

```
6
```

#####　linalg.det(a)

计算矩阵行列式

In [29]:

```
np.linalg.det(b)# 5*9-2*6=45-12=33 # 计算行列式
```

Out[29]:

```
33.0
```

In [30]:

```
np.linalg.det(a) # 1*5-2*4=5-8=-3
```

Out[30]:

```
-2.9999999999999996
```

#####　linalg.inv(a)

计算方阵的逆

In [31]:

```
np.linalg.inv(a) # 计算a矩阵的逆矩阵
```

Out[31]:

```
array([[-1.66666667,  0.66666667],
       [ 1.33333333, -0.33333333]])
```

[小栗子]: https://jalammar.github.io/visual-numpy/

计算均方误差MSE

![](https://cdn.jsdelivr.net/gh/CoderAngle/notebook-picgo@master/机器学习&深度学习/20200723210536.jpg)

用numpy进行表示

![](https://cdn.jsdelivr.net/gh/CoderAngle/notebook-picgo@master/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0&%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/20200723210537.png)

分别设置相应的预测值以及真实值



![](https://cdn.jsdelivr.net/gh/CoderAngle/notebook-picgo@master/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0&%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/20200723210538.png)

![](https://cdn.jsdelivr.net/gh/CoderAngle/notebook-picgo@master/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0&%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/20200723210539.jpg)

![](https://cdn.jsdelivr.net/gh/TheFoxFairy/ImgStg/202202090543487.jpeg)

![](https://cdn.jsdelivr.net/gh/CoderAngle/notebook-picgo@master/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0&%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/20200723210541.jpg)

In[1]:

```
import numpy as np

predictions = np.array([1,1,1]).T 
labels =np.array([1,2,3]).T

errors = 1/np.size(predictions)*np.sum(np.square(predictions-labels))
errors
```

Out[1]:

```
1.6666666666666665
```

> 注意进行计算时，需要知道矩阵的状态，才能保证按照公式计算无误